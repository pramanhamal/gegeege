<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Chess Game - Multiplayer</title>
    <style>
        body { margin: 0; font-family: 'Inter', sans-serif; background-color: #1a1a1a; color: #e0e0e0; overflow: hidden; display: flex; justify-content: center; align-items: center; height: 100vh; }
        #gameContainer { position: relative; width: 100%; height: 100%; }
        #info { position: absolute; top: 10px; left: 50%; transform: translateX(-50%); width: 90%; max-width: 700px; text-align: center; z-index: 100; padding: 10px; background-color: rgba(0,0,0,0.6); border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.5); }
        /* Updated #controlsBar for better spacing */
        #controlsBar { display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;}
        #playerInfo { margin-bottom: 5px; font-size: 0.9em;} /* Removed margin-right, space-between will handle */
        #status { font-size: 1em; margin-top:5px;}
        #messageBox { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: rgba(30, 30, 30, 0.97); color: white; padding: 25px; border-radius: 12px; box-shadow: 0 5px 20px rgba(0,0,0,0.6); z-index: 1000; display: none; text-align: center; border: 1px solid #444; }
        #messageBox button { background-color: #007bff; color: white; border: none; padding: 12px 20px; border-radius: 6px; cursor: pointer; margin-top: 20px; font-size: 1em; transition: background-color 0.3s; }
        #messageBox button:hover { background-color: #0056b3; }
        canvas { display: block; }
        #nameEntryModal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.8); z-index: 2000; display: flex; justify-content: center; align-items: center; }
        #nameEntryBox { background-color: #2c2c2c; padding: 30px; border-radius: 10px; text-align: center; box-shadow: 0 0 20px rgba(0,0,0,0.5); }
        #nameEntryBox h2 { margin-top: 0; color: #f0f0f0; }
        #nameInput { padding: 10px; margin: 10px 0; border-radius: 5px; border: 1px solid #555; background-color: #333; color: #fff; width: 80%; }
        #joinGameButton { background-color: #28a745; color: white; padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer; }
        #joinGameButton:hover { background-color: #1e7e34; }
        .confetti { position: absolute; width: 10px; height: 10px; background-color: red; opacity: 0.7; border-radius: 50%; }
        #resetGameButton { background-color: #dc3545; color: white; padding: 8px 12px; border-radius: 5px; cursor: pointer; font-size: 0.9em; }
        #resetGameButton:hover { background-color: #c82333; }
    </style>
    <script src="https://cdn.tailwindcss.com"></script>
    <script async src="https://ga.jspm.io/npm:es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.138.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.138.0/examples/jsm/"
        }
    }
    </script>
</head>
<body>
    <div id="nameEntryModal">
        <div id="nameEntryBox">
            <h2>Enter Your Name</h2>
            <input type="text" id="nameInput" placeholder="Player Name">
            <button id="joinGameButton">Join Game</button>
        </div>
    </div>

    <div id="gameContainer" style="display: none;">
        <div id="info">
            <div id="controlsBar">
                {/* Removed mr-auto from h1, space-between on parent handles it */}
                <h1 class="text-2xl font-bold">3D Chess</h1> 
                <button id="resetGameButton">Reset Game</button>
            </div>
            <div id="playerInfo">Your Name: <span id="localPlayerName"></span> (<span id="localPlayerColor"></span>)</div>
            <p id="turnInfo" class="text-lg">Loading game...</p>
            <p id="status" class="text-md">Waiting for players...</p>
        </div>
        <div id="messageBox">
            <p id="messageText"></p>
            <button id="messageButton">OK</button>
        </div>
        </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, getDoc, onSnapshot, updateDoc, serverTimestamp, writeBatch, deleteField } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- Firebase Setup ---
        // IMPORTANT: Replace this with your actual Firebase config object!
        const firebaseConfig = {
            apiKey: "AIzaSyCdvtD3EZ676BvyI9SWSity90GF4rSu4I0", // Replace
            authDomain: "chess-8c8fe.firebaseapp.com", // Replace
            projectId: "chess-8c8fe", // Replace
            storageBucket: "chess-8c8fe.firebasestorage.app", // Replace
            messagingSenderId: "165910435435", // Replace
            appId: "1:165910435435:web:254d1a99e528b86458432e", // Replace
            measurementId: "G-DJV31JNSD8" // Optional, but good to have
        };
        
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        const appId = firebaseConfig.projectId || 'default-chess-app'; 
        const gameId = 'defaultPublicGame'; 
        const gameDocRef = doc(db, `/artifacts/${appId}/public/data/chessGames/${gameId}`);

        let localPlayerAuthId = null;
        let localPlayerName = ''; 
        let localPlayerColor = null; 
        let unsubscribeGameListener = null;
        let gameInitialized = false;

        // --- Scene Setup ---
        let scene, camera, renderer, controls;
        let raycaster, mouse;

        // --- Game State ---
        const boardSize = 8;
        const squareSize = 10; 
        const pieceElevation = 0.5;
        let boardSquares = []; 
        let chessPieces = {}; 
        let localBoardRepresentation = new Array(boardSize).fill(null).map(() => new Array(boardSize).fill(null)); 
        let gameData = {}; 
        let selectedPiece = null; 
        let highlightedSquares = []; 
        let gameOver = false; 

        const pieceColors = { white: 0xdddddd, black: 0x222222 };
        const squareColors = { light: 0xDEB887, dark: 0x8B4513, highlight: 0x32CD32, selected: 0xFFD700 };

        // --- DOM Elements ---
        const turnInfoElement = document.getElementById('turnInfo');
        const statusElement = document.getElementById('status');
        const messageBox = document.getElementById('messageBox');
        const messageText = document.getElementById('messageText');
        const messageButton = document.getElementById('messageButton');
        const nameEntryModal = document.getElementById('nameEntryModal');
        const nameInput = document.getElementById('nameInput');
        const joinGameButton = document.getElementById('joinGameButton');
        const gameContainer = document.getElementById('gameContainer');
        const localPlayerNameSpan = document.getElementById('localPlayerName');
        const localPlayerColorSpan = document.getElementById('localPlayerColor');
        const resetGameButton = document.getElementById('resetGameButton');

        // --- Confetti ---
        let confettiParticles = [];
        const confettiColors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff, 0x00ffff];

        // --- Core Utility Functions ---
        function isValidSquare(row, col) {
            return row >= 0 && row < boardSize && col >= 0 && col < boardSize;
        }

        function showMessage(text) {
            if (messageText && messageBox) {
                messageText.textContent = text;
                messageBox.style.display = 'block';
            } else {
                console.error("showMessage DOM elements (messageText or messageBox) not found. Fallback to alert. Message:", text);
                alert(text); 
            }
        }

        function onWindowResize() {
            if(!camera || !renderer) return; 
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function buildTempBoardFromPiecesData(currentPiecesData) {
            let tempBoard = new Array(boardSize).fill(null).map(() => new Array(boardSize).fill(null));
            if (currentPiecesData) {
                for (const pieceId in currentPiecesData) {
                    const pData = currentPiecesData[pieceId];
                    if (pData && isValidSquare(pData.row, pData.col)) { 
                        tempBoard[pData.row][pData.col] = pieceId; 
                    }
                }
            }
            return tempBoard;
        }
        
        function findKingSimulated(color, currentPiecesData) { 
            if (!currentPiecesData) return null;
            for (const pieceId in currentPiecesData) {
                const pData = currentPiecesData[pieceId];
                if (pData && pData.type === 'king' && pData.color === color) return pData; 
            }
            return null; 
        }

        function isSquareAttackedSimulated(targetRow, targetCol, attackerColor, currentPiecesData) {
            if (!currentPiecesData) return false;
            const tempBoardForPathing = buildTempBoardFromPiecesData(currentPiecesData);

            for (const pieceId in currentPiecesData) {
                const pieceData = currentPiecesData[pieceId];
                if (!pieceData || pieceData.color !== attackerColor) continue;
                const {row: pieceRow, col: pieceCol, type: pieceType} = pieceData;

                if (pieceType === 'pawn') { const direction = attackerColor === 'white' ? -1 : 1; if (targetRow === pieceRow + direction && (targetCol === pieceCol - 1 || targetCol === pieceCol + 1)) return true;
                } else if (pieceType === 'knight') { const knightMoves = [ { dr: -2, dc: -1 }, { dr: -2, dc: 1 }, { dr: -1, dc: -2 }, { dr: -1, dc: 2 }, { dr: 1, dc: -2 }, { dr: 1, dc: 2 }, { dr: 2, dc: -1 }, { dr: 2, dc: 1 }]; for (const move of knightMoves) if (pieceRow + move.dr === targetRow && pieceCol + move.dc === targetCol) return true;
                } else if (pieceType === 'king') { const kingMoves = [ { dr: -1, dc: -1 }, { dr: -1, dc: 0 }, { dr: -1, dc: 1 }, { dr: 0, dc: -1 }, { dr: 0, dc: 1 }, { dr: 1, dc: -1 }, { dr: 1, dc: 0 }, { dr: 1, dc: 1 }]; for (const move of kingMoves) if (pieceRow + move.dr === targetRow && pieceCol + move.dc === targetCol) return true;
                } else if (pieceType === 'rook' || pieceType === 'queen') { 
                    if (pieceRow === targetRow || pieceCol === targetCol) { let pathClear = true;
                        if (pieceRow === targetRow) { for (let c = Math.min(pieceCol, targetCol) + 1; c < Math.max(pieceCol, targetCol); c++) if (tempBoardForPathing[pieceRow][c]) { pathClear = false; break; }
                        } else { for (let r = Math.min(pieceRow, targetRow) + 1; r < Math.max(pieceRow, targetRow); r++) if (tempBoardForPathing[r][pieceCol]) { pathClear = false; break; } }
                        if (pathClear) return true;
                    }
                }
                if (pieceType === 'bishop' || pieceType === 'queen') {
                     if (Math.abs(pieceRow - targetRow) === Math.abs(pieceCol - targetCol)) { let pathClear = true; const dr = Math.sign(targetRow - pieceRow); const dc = Math.sign(targetCol - pieceCol);
                        for (let k = 1; k < Math.abs(pieceRow - targetRow); k++) if (tempBoardForPathing[pieceRow + dr * k][pieceCol + dc * k]) { pathClear = false; break; }
                        if (pathClear) return true;
                    }
                }
            }
            return false;
        }

        function isKingInCheckSimulated(kingColor, currentPiecesData) { 
            const kingData = findKingSimulated(kingColor, currentPiecesData);
            if (!kingData) { console.warn(`isKingInCheckSimulated: King data not found for ${kingColor}`); return false; }
            return isSquareAttackedSimulated(kingData.row, kingData.col, kingColor === 'white' ? 'black' : 'white', currentPiecesData);
        }


        // --- Event Listeners & Main Logic Flow ---
        messageButton.addEventListener('click', () => { if(messageBox) messageBox.style.display = 'none'; });
        joinGameButton.addEventListener('click', handleJoinGame);
        if(resetGameButton) resetGameButton.addEventListener('click', handleResetGame); 
        
        onAuthStateChanged(auth, async (user) => {
            console.log(`[onAuthStateChanged] Fired. User:`, user);
            if (user) {
                localPlayerAuthId = user.uid;
                console.log(`[onAuthStateChanged] localPlayerAuthId set to: '${localPlayerAuthId}'`);
                if (localPlayerName && !gameInitialized) { 
                    console.log(`[onAuthStateChanged] User authenticated and localPlayerName ('${localPlayerName}') is set. Proceeding to setupGameSession.`);
                    await setupGameSession();
                } else if (gameInitialized) {
                    console.log(`[onAuthStateChanged] User authenticated, game already initialized. localPlayerName: '${localPlayerName}'`);
                    if(!unsubscribeGameListener && scene) listenToGameUpdates(); 
                } else {
                    console.warn(`[onAuthStateChanged] User authenticated, but localPlayerName ('${localPlayerName}') is not set yet OR game already initialized.`);
                }
            } else { 
                console.log("[onAuthStateChanged] No user / signed out.");
                localPlayerAuthId = null;
                if (gameInitialized && localPlayerColor) { 
                    localPlayerName = ''; 
                    localPlayerColor = null;
                    if(localPlayerNameSpan) localPlayerNameSpan.textContent = ""; 
                    if(localPlayerColorSpan) localPlayerColorSpan.textContent = "";
                }
                gameInitialized = false; 
                
                if(nameEntryModal) nameEntryModal.style.display = 'flex';
                if(gameContainer) gameContainer.style.display = 'none';
                if(unsubscribeGameListener) { unsubscribeGameListener(); unsubscribeGameListener = null; }
                if(turnInfoElement) turnInfoElement.textContent = "Disconnected.";
                if(statusElement) statusElement.textContent = "Please enter your name to join.";
            }
        });

        async function handleJoinGame() {
            const nameFromInput = nameInput.value.trim();
            console.log(`[handleJoinGame] Attempting to join with name: '${nameFromInput}'`);

            if (!nameFromInput) {
                alert("Please enter your name."); return;
            }
            localPlayerName = nameFromInput; 

            if(nameEntryModal) nameEntryModal.style.display = 'none';
            if(gameContainer) gameContainer.style.display = 'block';
            if(statusElement) statusElement.textContent = "Authenticating...";
            if(localPlayerNameSpan) localPlayerNameSpan.textContent = localPlayerName; 

            try {
                if (auth.currentUser && auth.currentUser.uid) {
                    localPlayerAuthId = auth.currentUser.uid; 
                    console.log(`[handleJoinGame] User already authenticated (UID: ${localPlayerAuthId}). localPlayerName is '${localPlayerName}'. Proceeding to setupGameSession.`);
                    if (!gameInitialized) await setupGameSession(); 
                } else if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) { 
                    console.log(`[handleJoinGame] Attempting signInWithCustomToken. localPlayerName is '${localPlayerName}'.`);
                    await signInWithCustomToken(auth, __initial_auth_token);
                } else {
                    console.log(`[handleJoinGame] Attempting signInAnonymously. localPlayerName is '${localPlayerName}'.`);
                    await signInAnonymously(auth);
                }
            } catch (error) {
                console.error("[handleJoinGame] Error during auth:", error);
                showMessage("Authentication error. Please refresh and try again.");
                if(nameEntryModal) nameEntryModal.style.display = 'flex'; 
                if(gameContainer) gameContainer.style.display = 'none';
                localPlayerName = ''; 
                if(localPlayerNameSpan) localPlayerNameSpan.textContent = "";
            }
        }
        
        async function setupGameSession() {
            if (gameInitialized) { console.log("[setupGameSession] Already initialized, skipping."); return; }
            console.log(`[setupGameSession] Entered. localPlayerAuthId: '${localPlayerAuthId}', localPlayerName: '${localPlayerName}'`);
            
            if (!localPlayerAuthId || !localPlayerName) { 
                console.error(`[setupGameSession] Returning early. AuthId: ${localPlayerAuthId}, Name: ${localPlayerName}. This indicates a problem in the flow.`);
                if(statusElement) statusElement.textContent = "Error: Missing player details. Please refresh.";
                return;
            }
            
            gameInitialized = true; 

            if(localPlayerNameSpan) localPlayerNameSpan.textContent = localPlayerName; 
            if(statusElement) statusElement.textContent = "Connecting to game room...";

            try {
                const gameSnap = await getDoc(gameDocRef);
                let players = gameSnap.exists() ? gameSnap.data().players || {} : {};
                let playerIds = gameSnap.exists() ? gameSnap.data().playerIds || {} : {};
                let currentPiecesData = gameSnap.exists() ? gameSnap.data().piecesData || null : null;
                let gameIsOver = gameSnap.exists() ? gameSnap.data().gameOver : false;
                
                let assignedColorThisSession = null;

                if (playerIds.white === localPlayerAuthId) assignedColorThisSession = 'white';
                else if (playerIds.black === localPlayerAuthId) assignedColorThisSession = 'black';
                
                if (!assignedColorThisSession) { 
                    if (!playerIds.white || players.white === null) { assignedColorThisSession = 'white'; }
                    else if (!playerIds.black || players.black === null) { assignedColorThisSession = 'black'; }
                }

                localPlayerColor = assignedColorThisSession;
                
                if (localPlayerColor) { 
                    players[localPlayerColor] = localPlayerName; 
                    playerIds[localPlayerColor] = localPlayerAuthId; 
                    if(localPlayerColorSpan) localPlayerColorSpan.textContent = localPlayerColor;
                    console.log(`[setupGameSession] Player ${localPlayerName} (${localPlayerAuthId}) assigned/confirmed as ${localPlayerColor}`);
                } else {
                    if(localPlayerColorSpan) localPlayerColorSpan.textContent = "Spectator";
                    showMessage("Game is currently full or error assigning color. You are spectating.");
                    if(statusElement) statusElement.textContent = "Spectating.";
                    console.log(`[setupGameSession] Player ${localPlayerName} could not be assigned a color. Spectating.`);
                }

                if ((!currentPiecesData || gameIsOver) && localPlayerColor) { 
                    console.log(`[setupGameSession] Initializing/Resetting game data with player ${localPlayerColor}: ${localPlayerName}`);
                    const initialPieceSetup = setupInitialPiecesData(); 
                    const initialGameData = {
                        piecesData: initialPieceSetup, 
                        currentPlayer: 'white',
                        players: players, 
                        playerIds: playerIds, 
                        gameOver: false, winner: null, lastMoveTimestamp: serverTimestamp(),
                        check: false, checkedPlayer: null
                    };
                    await setDoc(gameDocRef, initialGameData); 
                } else if (localPlayerColor) { 
                    console.log(`[setupGameSession] Updating game doc for player ${localPlayerColor}: ${localPlayerName}`);
                    await updateDoc(gameDocRef, {
                        [`players.${localPlayerColor}`]: localPlayerName, 
                        [`playerIds.${localPlayerColor}`]: localPlayerAuthId
                    });
                }

                if (!scene) { 
                    console.log(`[setupGameSession] Initializing Three.js scene.`);
                    initThreeJS(); 
                } else { 
                     if (localPlayerColor && camera) setCameraForPlayer(localPlayerColor);
                }
                listenToGameUpdates(); 

            } catch (error) {
                console.error("[setupGameSession] Error during Firestore operations:", error);
                showMessage("Failed to connect to game room: " + error.message);
                gameInitialized = false; 
                if(nameEntryModal) nameEntryModal.style.display = 'flex'; 
                if(gameContainer) gameContainer.style.display = 'none';
                if(localPlayerNameSpan) localPlayerNameSpan.textContent = "";
                if(localPlayerColorSpan) localPlayerColorSpan.textContent = "";
            }
        }

        async function handleResetGame() {
            if (!localPlayerColor) { 
                showMessage("Only active players can reset the game.");
                return;
            }
            console.log(`[handleResetGame] Player ${localPlayerName} (${localPlayerColor}) is attempting to reset the game.`);
            
            try {
                const initialPieceSetup = setupInitialPiecesData();
                const currentPlayers = gameData.players || {}; 
                const currentPlayerIds = gameData.playerIds || {}; 

                const resetGameData = {
                    piecesData: initialPieceSetup,
                    currentPlayer: 'white',
                    players: currentPlayers, 
                    playerIds: currentPlayerIds,
                    gameOver: false,
                    winner: null,
                    check: false,
                    checkedPlayer: null,
                    lastMoveTimestamp: serverTimestamp()
                };
                await setDoc(gameDocRef, resetGameData); 
                showMessage("Game has been reset!");
                console.log("[handleResetGame] Game reset successfully in Firestore.");
            } catch (error) {
                console.error("[handleResetGame] Error resetting game:", error);
                showMessage("Error resetting game: " + error.message);
            }
        }


        function listenToGameUpdates() { 
            if (unsubscribeGameListener) unsubscribeGameListener(); 
            console.log("[listenToGameUpdates] Attaching Firestore listener.");
            unsubscribeGameListener = onSnapshot(gameDocRef, (docSnap) => {
                console.log("[onSnapshot] Game data received from Firestore:", docSnap.exists() ? docSnap.data() : "No document");
                if (docSnap.exists()) {
                    gameData = docSnap.data();
                    if (!gameData.piecesData) { 
                        console.warn("[onSnapshot] piecesData missing from Firestore document. Game might need reset or initialization.");
                        if(statusElement) statusElement.textContent = "Game data incomplete. Waiting for initialization...";
                        if (localPlayerColor && !gameData.gameOver) { 
                             if(gameData.currentPlayer === localPlayerColor && Object.keys(gameData.players || {}).length <= 1) {
                                console.log("Attempting to re-initialize game data as first player.");
                             }
                        }
                        return; 
                    }
                    gameOver = gameData.gameOver; 
                    updateLocalBoardFromFirestore(gameData.piecesData); 
                    updateTurnInfo();
                    
                    if (gameData.gameOver && gameData.winner) {
                        const winnerName = gameData.players?.[gameData.winner] || gameData.winner;
                        const message = gameData.winner === 'draw' ? "Stalemate! The game is a draw." : `Checkmate! ${winnerName} wins!`;
                        if(statusElement) statusElement.textContent = message; showMessage(message);
                        if (gameData.winner !== 'draw' && ((localPlayerColor && gameData.winner === localPlayerColor) || (gameData.players?.[gameData.winner] === localPlayerName))) {
                            triggerConfetti();
                        }
                    } else if (gameData.check && gameData.checkedPlayer) {
                        const checkedPlayerName = gameData.players?.[gameData.checkedPlayer] || gameData.checkedPlayer.toUpperCase();
                        const message = `${checkedPlayerName}'s King is in Check!`;
                        if (gameData.checkedPlayer === localPlayerColor) {
                            if(statusElement) statusElement.textContent = `Your King is in Check!`; showMessage(`Your King is in Check!`);
                         } else {
                            if(statusElement) statusElement.textContent = message;
                         }
                    }
                } else {
                    if(statusElement) statusElement.textContent = "Game data not found. Waiting for game to start...";
                     if (!localPlayerColor && localPlayerName) { 
                        if(nameEntryModal) nameEntryModal.style.display = 'flex';
                        if(gameContainer) gameContainer.style.display = 'none';
                        showMessage("Game room closed or not found. Please try joining again.");
                        gameInitialized = false;
                    }
                }
            }, (error) => {
                console.error("[onSnapshot] Error listening to game updates:", error);
                showMessage("Connection to game lost. Please refresh.");
            });
        }

        function updateLocalBoardFromFirestore(firestorePiecesData) { 
            if (!scene) { console.warn("[updateLocalBoardFromFirestore] Scene not ready."); return; }

            for (const pieceId in chessPieces) {
                if(chessPieces[pieceId]) scene.remove(chessPieces[pieceId]);
                disposePiece(chessPieces[pieceId]);
            }
            chessPieces = {}; 
            localBoardRepresentation = new Array(boardSize).fill(null).map(() => new Array(boardSize).fill(null)); 

            if (firestorePiecesData) {
                for (const pieceId in firestorePiecesData) {
                    const data = firestorePiecesData[pieceId];
                    if (!data) continue; 
                    let piece3D;
                    if (data.type === 'pawn') piece3D = createPawn(data.color);
                    else if (data.type === 'rook') piece3D = createRook(data.color);
                    else if (data.type === 'knight') piece3D = createKnight(data.color);
                    else if (data.type === 'bishop') piece3D = createBishop(data.color);
                    else if (data.type === 'queen') piece3D = createQueen(data.color);
                    else if (data.type === 'king') piece3D = createKing(data.color);
                    
                    if (piece3D) {
                        piece3D.userData = { ...data, id: pieceId }; 
                        const pieceY = piece3D.userData.totalHeight ? piece3D.userData.totalHeight / 2 + pieceElevation : squareSize * 0.5 + pieceElevation;
                        piece3D.position.set( (data.col - boardSize / 2 + 0.5) * squareSize, pieceY, (data.row - boardSize / 2 + 0.5) * squareSize );
                        if (data.color === 'black' && data.type !== 'pawn') piece3D.rotation.y = Math.PI;
                        scene.add(piece3D);
                        chessPieces[pieceId] = piece3D;
                        if (isValidSquare(data.row, data.col)) { 
                           localBoardRepresentation[data.row][data.col] = { pieceId: pieceId, ...data }; 
                        }
                    }
                }
            }
            if (localPlayerColor && camera) { 
                setCameraForPlayer(localPlayerColor);
            } else if (!localPlayerColor && camera) { 
                camera.position.set(0, 90, 90); camera.lookAt(0,0,0); if(controls) controls.update();
            }
             if (selectedPiece && !chessPieces[selectedPiece.userData.id]) { 
                selectedPiece = null;
                clearHighlights();
            }
        }
        
        function setCameraForPlayer(playerColor) { 
            if (!camera) return;
            if (playerColor === 'white') { camera.position.set(0, 90, 90); } 
            else if (playerColor === 'black') { camera.position.set(0, 90, -90); }
            camera.lookAt(0, 0, 0);
            if (controls) controls.update();
            camera.userData.povSet = true; camera.userData.playerColor = playerColor;
        }

        function updateTurnInfo() { 
            if (!gameData || Object.keys(gameData).length === 0) {
                if(turnInfoElement) turnInfoElement.textContent = "Loading game data..."; return;
            }
            if (gameData.gameOver) { return; } 
            if (gameData.currentPlayer) {
                const currentPlayerName = gameData.players?.[gameData.currentPlayer] || gameData.currentPlayer.toUpperCase();
                if(turnInfoElement) turnInfoElement.textContent = `${currentPlayerName}'s Turn (${gameData.currentPlayer})`;
                if (gameData.currentPlayer === localPlayerColor) {
                    if(statusElement) statusElement.textContent = "Your turn. Select a piece.";
                } else {
                    if(statusElement) statusElement.textContent = `Waiting for ${currentPlayerName}...`;
                }
            } else {
                if(turnInfoElement) turnInfoElement.textContent = "Waiting for player assignment...";
            }
        }

        function initThreeJS() { 
            scene = new THREE.Scene(); scene.background = new THREE.Color(0x667788);
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 2000);
            camera.position.set(0,90,90); camera.lookAt(0,0,0);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight); renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            if(gameContainer) gameContainer.appendChild(renderer.domElement); 
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8); scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0); 
            directionalLight.position.set(60, 120, 70); directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048; directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 50; directionalLight.shadow.camera.far = 300;
            directionalLight.shadow.camera.left = -100; directionalLight.shadow.camera.right = 100;
            directionalLight.shadow.camera.top = 100; directionalLight.shadow.camera.bottom = -100;
            scene.add(directionalLight);
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; controls.dampingFactor = 0.05; controls.screenSpacePanning = false;
            controls.minDistance = 30; controls.maxDistance = 250; controls.maxPolarAngle = Math.PI / 2 - 0.03; 
            raycaster = new THREE.Raycaster(); mouse = new THREE.Vector2();
            createChessboard(); 
            window.addEventListener('resize', onWindowResize, false); 
            if(renderer.domElement) {
                renderer.domElement.addEventListener('mousedown', onMouseDown, false);
                renderer.domElement.addEventListener('touchstart', onTouchStart, false); 
            } else {
                console.error("Renderer DOM element not found for event listeners.");
            }
            if(!gameData.gameOver) animate(); 
        }

        function createChessboard() {
            const squareGeo = new THREE.BoxGeometry(squareSize, 1, squareSize);
            for (let i = 0; i < boardSize; i++) {
                boardSquares[i] = [];
                for (let j = 0; j < boardSize; j++) {
                    const isLightSquare = (i + j) % 2 === 0;
                    const squareMat = new THREE.MeshStandardMaterial({ color: isLightSquare ? squareColors.light : squareColors.dark, metalness: 0.2, roughness: 0.8 });
                    const square = new THREE.Mesh(squareGeo, squareMat);
                    square.position.set((j - boardSize / 2 + 0.5) * squareSize, 0, (i - boardSize / 2 + 0.5) * squareSize);
                    square.receiveShadow = true;
                    square.userData = { type: 'square', row: i, col: j, originalColor: squareMat.color.getHex() };
                    scene.add(square); boardSquares[i][j] = square;
                }
            }
        }
        
        function createPawn(color) { 
            const group = new THREE.Group(); const material = new THREE.MeshStandardMaterial({ color: pieceColors[color], metalness: 0.5, roughness: 0.4 });
            const baseRadius = squareSize * 0.22; const midRadius = squareSize * 0.18; const headRadius = squareSize * 0.2;
            const baseHeight = squareSize * 0.15; const stemHeight = squareSize * 0.3;
            const baseGeo = new THREE.CylinderGeometry(baseRadius, baseRadius, baseHeight, 24); const base = new THREE.Mesh(baseGeo, material); base.castShadow = true; group.add(base);
            const stemGeo = new THREE.CylinderGeometry(midRadius, baseRadius * 0.8, stemHeight, 24); const stem = new THREE.Mesh(stemGeo, material); stem.position.y = baseHeight / 2 + stemHeight / 2; stem.castShadow = true; group.add(stem);
            const headGeo = new THREE.SphereGeometry(headRadius, 24, 16); const head = new THREE.Mesh(headGeo, material); head.position.y = baseHeight / 2 + stemHeight + headRadius * 0.7; head.castShadow = true; group.add(head);
            group.userData = { type: 'pawn', color: color, totalHeight: baseHeight + stemHeight + headRadius * 1.4 }; return group;
        }
        function createRook(color) { 
            const group = new THREE.Group(); const material = new THREE.MeshStandardMaterial({ color: pieceColors[color], metalness: 0.6, roughness: 0.3 });
            const baseRadius = squareSize * 0.3; const midRadius = squareSize * 0.25; const topRadius = squareSize * 0.28;
            const baseHeight = squareSize * 0.2; const shaftHeight = squareSize * 0.5; const topHeight = squareSize * 0.25; const crenellationHeight = squareSize * 0.2; const crenellationWidth = squareSize * 0.15;
            const baseGeo = new THREE.CylinderGeometry(baseRadius * 1.1, baseRadius, baseHeight, 32); const base = new THREE.Mesh(baseGeo, material); base.castShadow = true; group.add(base);
            const shaftGeo = new THREE.CylinderGeometry(midRadius, midRadius, shaftHeight, 32); const shaft = new THREE.Mesh(shaftGeo, material); shaft.position.y = baseHeight / 2 + shaftHeight / 2; shaft.castShadow = true; group.add(shaft);
            const topGeo_ = new THREE.CylinderGeometry(topRadius, topRadius * 0.9, topHeight, 32); const top_ = new THREE.Mesh(topGeo_, material); top_.position.y = baseHeight / 2 + shaftHeight + topHeight / 2; top_.castShadow = true; group.add(top_);
            const numCrenellations = 6; for (let i = 0; i < numCrenellations; i++) { const angle = (i / numCrenellations) * Math.PI * 2; const crenGeo = new THREE.BoxGeometry(crenellationWidth, crenellationHeight, crenellationWidth * 0.8); const cren = new THREE.Mesh(crenGeo, material); cren.position.set( Math.cos(angle) * (topRadius - crenellationWidth * 0.3), baseHeight / 2 + shaftHeight + topHeight + crenellationHeight / 2 - 0.05, Math.sin(angle) * (topRadius - crenellationWidth * 0.3)); cren.lookAt(0, cren.position.y, 0); cren.rotation.y += Math.PI / 2; cren.castShadow = true; group.add(cren); }
            group.userData = { type: 'rook', color: color, hasMoved: false, totalHeight: baseHeight + shaftHeight + topHeight + crenellationHeight }; return group;
        }
        function createKnight(color) {
            const group = new THREE.Group(); const material = new THREE.MeshStandardMaterial({ color: pieceColors[color], metalness: 0.5, roughness: 0.4 });
            const baseWidth = squareSize * 0.35; const baseHeight = squareSize * 0.2; const bodyHeight = squareSize * 0.4; const bodyWidth = squareSize * 0.25; const bodyDepth = squareSize * 0.3; const neckRadius = squareSize * 0.1; const neckHeight = squareSize * 0.3; const headLength = squareSize * 0.4; const headWidth = squareSize * 0.2; const headHeightVal = squareSize * 0.25;
            const baseGeo = new THREE.CylinderGeometry(baseWidth, baseWidth*0.8, baseHeight, 32); const base = new THREE.Mesh(baseGeo, material); base.castShadow = true; group.add(base);
            const bodyGeo = new THREE.BoxGeometry(bodyWidth, bodyHeight, bodyDepth); const body = new THREE.Mesh(bodyGeo, material); body.position.y = baseHeight/2 + bodyHeight/2; body.rotation.y = Math.PI / 12; body.castShadow = true; group.add(body);
            const neckGeo = new THREE.CylinderGeometry(neckRadius, neckRadius * 0.8, neckHeight, 16); const neck = new THREE.Mesh(neckGeo, material); neck.position.set(bodyWidth * 0.1, baseHeight/2 + bodyHeight + neckHeight * 0.4, bodyDepth * 0.1); neck.rotation.z = Math.PI / 6; neck.rotation.x = -Math.PI / 12; neck.castShadow = true; group.add(neck);
            const headGeo = new THREE.BoxGeometry(headWidth, headHeightVal, headLength); const head = new THREE.Mesh(headGeo, material); head.position.set( neck.position.x + Math.sin(neck.rotation.z) * neckHeight * 0.5, neck.position.y + Math.cos(neck.rotation.z) * neckHeight * 0.5 - headHeightVal*0.1, neck.position.z + headLength * 0.3 ); head.rotation.z = Math.PI / 5; head.castShadow = true; group.add(head);
            for(let i=0; i<3; i++){ const maneGeo = new THREE.BoxGeometry(squareSize*0.05, squareSize*0.15, squareSize*0.05); const manePart = new THREE.Mesh(maneGeo, material); manePart.position.set( neck.position.x - Math.sin(neck.rotation.z) * (neckHeight * 0.2 * i), neck.position.y + Math.cos(neck.rotation.z) * (neckHeight * 0.2 * i) + squareSize*0.07, neck.position.z - squareSize*0.05); manePart.rotation.z = Math.PI / 6; group.add(manePart); }
            group.userData = { type: 'knight', color: color, totalHeight: baseHeight + bodyHeight + neckHeight }; return group;
        }
        function createBishop(color) { 
            const group = new THREE.Group(); const material = new THREE.MeshStandardMaterial({ color: pieceColors[color], metalness: 0.5, roughness: 0.4 });
            const baseRadius = squareSize * 0.28; const midRadius = squareSize * 0.2; const headRadius = squareSize * 0.22; const baseHeight = squareSize * 0.2; const stemHeight = squareSize * 0.5; const headHeight = squareSize * 0.4;
            const baseGeo = new THREE.CylinderGeometry(baseRadius, baseRadius * 0.9, baseHeight, 32); const base = new THREE.Mesh(baseGeo, material); base.castShadow = true; group.add(base);
            const stemGeo = new THREE.CylinderGeometry(midRadius * 0.8, midRadius, stemHeight, 32); const stem = new THREE.Mesh(stemGeo, material); stem.position.y = baseHeight / 2 + stemHeight / 2; stem.castShadow = true; group.add(stem);
            const mitreGeo = new THREE.ConeGeometry(headRadius, headHeight, 32); const mitre = new THREE.Mesh(mitreGeo, material); mitre.position.y = baseHeight / 2 + stemHeight + headHeight / 2; mitre.castShadow = true; group.add(mitre);
            const topSphereGeo = new THREE.SphereGeometry(squareSize * 0.07, 16, 16); const topSphere = new THREE.Mesh(topSphereGeo, material); topSphere.position.y = baseHeight / 2 + stemHeight + headHeight + squareSize * 0.03; topSphere.castShadow = true; group.add(topSphere);
            group.userData = { type: 'bishop', color: color, totalHeight: baseHeight + stemHeight + headHeight + squareSize * 0.07 }; return group;
        }
        function createQueen(color) { 
            const group = new THREE.Group(); const material = new THREE.MeshStandardMaterial({ color: pieceColors[color], metalness: 0.7, roughness: 0.2 });
            const baseRadius = squareSize * 0.32; const midSectionRadius = squareSize * 0.22; const crownBaseRadius = squareSize * 0.28; const baseHeight = squareSize * 0.25; const stemHeight = squareSize * 0.4; const crownBaseHeight = squareSize * 0.15; const crownPointHeight = squareSize * 0.25;
            const baseGeo = new THREE.CylinderGeometry(baseRadius, baseRadius * 0.85, baseHeight, 32); const base = new THREE.Mesh(baseGeo, material); base.castShadow = true; group.add(base);
            const stemGeo = new THREE.CylinderGeometry(midSectionRadius * 0.8, midSectionRadius, stemHeight, 32); const stem = new THREE.Mesh(stemGeo, material); stem.position.y = baseHeight / 2 + stemHeight / 2; stem.castShadow = true; group.add(stem);
            const crownBaseGeo_ = new THREE.CylinderGeometry(crownBaseRadius, crownBaseRadius * 1.1, crownBaseHeight, 32); const crownBase_ = new THREE.Mesh(crownBaseGeo_, material); crownBase_.position.y = baseHeight / 2 + stemHeight + crownBaseHeight / 2; crownBase_.castShadow = true; group.add(crownBase_);
            const numCrownPoints = 7; for (let i = 0; i < numCrownPoints; i++) { const angle = (i / numCrownPoints) * Math.PI * 2; const pointGeo = new THREE.ConeGeometry(squareSize * 0.06, crownPointHeight, 8); const point = new THREE.Mesh(pointGeo, material); point.position.set( Math.cos(angle) * (crownBaseRadius * 0.9), baseHeight / 2 + stemHeight + crownBaseHeight + crownPointHeight * 0.4, Math.sin(angle) * (crownBaseRadius * 0.9)); point.castShadow = true; group.add(point); }
            const jewelGeo = new THREE.SphereGeometry(squareSize * 0.1, 16, 16); const jewel = new THREE.Mesh(jewelGeo, material); jewel.position.y = baseHeight / 2 + stemHeight + crownBaseHeight + crownPointHeight * 0.6; jewel.castShadow = true; group.add(jewel);
            group.userData = { type: 'queen', color: color, totalHeight: baseHeight + stemHeight + crownBaseHeight + crownPointHeight }; return group;
        }
        function createKing(color) { 
            const group = new THREE.Group(); const material = new THREE.MeshStandardMaterial({ color: pieceColors[color], metalness: 0.7, roughness: 0.2 });
            const baseRadius = squareSize * 0.33; const midSectionRadius = squareSize * 0.25; const topSectionRadius = squareSize * 0.28; const baseHeight = squareSize * 0.3; const stemHeight = squareSize * 0.5; const topHeight = squareSize * 0.2; const crossBarLength = squareSize * 0.25; const crossBarThickness = squareSize * 0.07; const crossHeight = squareSize * 0.3;
            const baseGeo = new THREE.CylinderGeometry(baseRadius, baseRadius * 0.9, baseHeight, 32); const base = new THREE.Mesh(baseGeo, material); base.castShadow = true; group.add(base);
            const stemGeo = new THREE.CylinderGeometry(midSectionRadius * 0.9, midSectionRadius, stemHeight, 32); const stem = new THREE.Mesh(stemGeo, material); stem.position.y = baseHeight / 2 + stemHeight / 2; stem.castShadow = true; group.add(stem);
            const topGeo_ = new THREE.CylinderGeometry(topSectionRadius, topSectionRadius * 0.85, topHeight, 32); const topSection_ = new THREE.Mesh(topGeo_, material); topSection_.position.y = baseHeight / 2 + stemHeight + topHeight / 2; topSection_.castShadow = true; group.add(topSection_);
            const crossYPos = baseHeight / 2 + stemHeight + topHeight + crossHeight / 2 - crossBarThickness;
            const vBarGeo = new THREE.BoxGeometry(crossBarThickness, crossHeight, crossBarThickness); const vBar = new THREE.Mesh(vBarGeo, material); vBar.position.y = crossYPos; vBar.castShadow = true; group.add(vBar);
            const hBarGeo = new THREE.BoxGeometry(crossBarLength, crossBarThickness, crossBarThickness); const hBar = new THREE.Mesh(hBarGeo, material); hBar.position.y = crossYPos + crossHeight * 0.1; hBar.castShadow = true; group.add(hBar);
            group.userData = { type: 'king', color: color, hasMoved: false, totalHeight: baseHeight + stemHeight + topHeight + crossHeight }; return group;
        }
        
        function setupInitialPiecesData() { 
            let initialPiecesData = {};
            function addInitialPiece(type, color, row, col, idSuffix, piecesMap) { 
               const pieceId = `${type}_${color[0]}_${idSuffix}`;
               piecesMap[pieceId] = { type, color, row, col, hasMoved: false, id: pieceId };
            }
            for (let i = 0; i < boardSize; i++) addInitialPiece('pawn', 'white', 6, i, i, initialPiecesData);
            let wCol = 0; 
            addInitialPiece('rook', 'white', 7, wCol++, '0', initialPiecesData); addInitialPiece('knight', 'white', 7, wCol++, '0', initialPiecesData); 
            addInitialPiece('bishop', 'white', 7, wCol++, '0', initialPiecesData); addInitialPiece('queen', 'white', 7, wCol++, '0', initialPiecesData);
            addInitialPiece('king', 'white', 7, wCol++, '0', initialPiecesData); addInitialPiece('bishop', 'white', 7, wCol++, '1', initialPiecesData);
            addInitialPiece('knight', 'white', 7, wCol++, '1', initialPiecesData); addInitialPiece('rook', 'white', 7, wCol++, '1', initialPiecesData);
            for (let i = 0; i < boardSize; i++) addInitialPiece('pawn', 'black', 1, i, i, initialPiecesData);
            let bCol = 0; 
            addInitialPiece('rook', 'black', 0, bCol++, '0', initialPiecesData); addInitialPiece('knight', 'black', 0, bCol++, '0', initialPiecesData);
            addInitialPiece('bishop', 'black', 0, bCol++, '0', initialPiecesData); addInitialPiece('queen', 'black', 0, bCol++, '0', initialPiecesData);
            addInitialPiece('king', 'black', 0, bCol++, '0', initialPiecesData); addInitialPiece('bishop', 'black', 0, bCol++, '1', initialPiecesData);
            addInitialPiece('knight', 'black', 0, bCol++, '1', initialPiecesData); addInitialPiece('rook', 'black', 0, bCol++, '1', initialPiecesData);
            return initialPiecesData; 
        }
        
        function isMoveLegal(pieceIdToMove, targetR, targetC, isCastlingMove = false, rookIdToMove = null, rookTargetC = null) {
            const currentPiecesData = gameData.piecesData; 
            const pieceData = currentPiecesData[pieceIdToMove];
            if (!pieceData) { console.error(`isMoveLegal: Piece data for ${pieceIdToMove} not found.`); return false;}
            const originalColor = pieceData.color;
            let tempPiecesData = JSON.parse(JSON.stringify(currentPiecesData));
            tempPiecesData[pieceIdToMove].row = targetR;
            tempPiecesData[pieceIdToMove].col = targetC;
            tempPiecesData[pieceIdToMove].hasMoved = true;
            let originalTempBoard = buildTempBoardFromPiecesData(currentPiecesData);
            const capturedPieceId = originalTempBoard[targetR][targetC];
            if (capturedPieceId && capturedPieceId !== pieceIdToMove) {
                 delete tempPiecesData[capturedPieceId]; 
            }
            if (isCastlingMove && rookIdToMove) {
                tempPiecesData[rookIdToMove].col = rookTargetC;
                tempPiecesData[rookIdToMove].hasMoved = true;
            }
            const kingIsSafe = !isKingInCheckSimulated(originalColor, tempPiecesData); 
            return kingIsSafe;
        }
        
        function getPotentialMoves(pieceId) { 
            const pieceData = gameData.piecesData[pieceId];
            if (!pieceData) return [];
            const { row, col, type, color } = pieceData;
            let potentialMoves = [];
            const currentBoardForPotential = buildTempBoardFromPiecesData(gameData.piecesData); 

            if (type === 'pawn') {
                const direction = color === 'white' ? -1 : 1;
                if (isValidSquare(row + direction, col) && !currentBoardForPotential[row + direction][col]) potentialMoves.push({ r: row + direction, c: col });
                if (((color === 'white' && row === 6) || (color === 'black' && row === 1)) && isValidSquare(row + 2 * direction, col) && !currentBoardForPotential[row + 2 * direction][col] && !currentBoardForPotential[row + direction][col]) potentialMoves.push({ r: row + 2 * direction, c: col });
                for (let dc of [-1, 1]) {
                    if (isValidSquare(row + direction, col + dc)) {
                        const targetPieceId = currentBoardForPotential[row + direction][col + dc];
                        if (targetPieceId && gameData.piecesData[targetPieceId] && gameData.piecesData[targetPieceId].color !== color) {
                            potentialMoves.push({ r: row + direction, c: col + dc });
                        }
                    }
                }
            } else if (type === 'knight') {
                const knightMoves = [ { dr: -2, dc: -1 }, { dr: -2, dc: 1 }, { dr: -1, dc: -2 }, { dr: -1, dc: 2 }, { dr: 1, dc: -2 }, { dr: 1, dc: 2 }, { dr: 2, dc: -1 }, { dr: 2, dc: 1 }];
                knightMoves.forEach(move => { 
                    const r = row + move.dr; const c = col + move.dc; 
                    if (isValidSquare(r, c)) {
                        const targetPieceId = currentBoardForPotential[r][c];
                        if (!targetPieceId || (gameData.piecesData[targetPieceId] && gameData.piecesData[targetPieceId].color !== color)) {
                            potentialMoves.push({ r, c });
                        }
                    }
                });
            } else if (type === 'king') {
                const kingMoves = [ { dr: -1, dc: -1 }, { dr: -1, dc: 0 }, { dr: -1, dc: 1 }, { dr: 0, dc: -1 }, { dr: 0, dc: 1 }, { dr: 1, dc: -1 }, { dr: 1, dc: 0 }, { dr: 1, dc: 1 }];
                kingMoves.forEach(move => { 
                    const r = row + move.dr; const c = col + move.dc; 
                    if (isValidSquare(r, c)) {
                        const targetPieceId = currentBoardForPotential[r][c];
                        if (!targetPieceId || (gameData.piecesData[targetPieceId] && gameData.piecesData[targetPieceId].color !== color)) {
                           potentialMoves.push({ r, c });
                        }
                    }
                });
            } else { 
                let directions = [];
                if (type === 'rook') directions = [ {dr: 0, dc: 1}, {dr: 0, dc: -1}, {dr: 1, dc: 0}, {dr: -1, dc: 0} ];
                if (type === 'bishop') directions = [ {dr: -1, dc: -1}, {dr: -1, dc: 1}, {dr: 1, dc: -1}, {dr: 1, dc: 1} ];
                if (type === 'queen') directions = [ {dr: 0, dc: 1}, {dr: 0, dc: -1}, {dr: 1, dc: 0}, {dr: -1, dc: 0}, {dr: -1, dc: -1}, {dr: -1, dc: 1}, {dr: 1, dc: -1}, {dr: 1, dc: 1} ];
                directions.forEach(dir => {
                    for (let k = 1; k < boardSize; k++) {
                        const r = row + dir.dr * k; const c = col + dir.dc * k;
                        if (!isValidSquare(r, c)) break;
                        const targetPieceId = currentBoardForPotential[r][c];
                        if (targetPieceId) { 
                            if (gameData.piecesData[targetPieceId] && gameData.piecesData[targetPieceId].color !== color) potentialMoves.push({ r, c }); 
                            break; 
                        }
                        potentialMoves.push({ r, c });
                    }
                });
            }
            return potentialMoves;
        }

        function highlightValidMoves(pieceId) { 
            const pieceData = gameData.piecesData[pieceId];
            if (!pieceData) return;
            const { row, col, type, color } = pieceData;

            let potentialMoves = getPotentialMoves(pieceId);
            let legalMoves = [];

            potentialMoves.forEach(move => { if (isMoveLegal(pieceId, move.r, move.c)) legalMoves.push(move); });

            if (type === 'king' && !pieceData.hasMoved && !isKingInCheckSimulated(color, gameData.piecesData)) {
                const tempBoardForCastleCheck = buildTempBoardFromPiecesData(gameData.piecesData);
                const kingsideRookCol = 7;
                const kingsideRookId = tempBoardForCastleCheck[row]?.[kingsideRookCol];
                if (kingsideRookId && gameData.piecesData[kingsideRookId]?.type === 'rook' && !gameData.piecesData[kingsideRookId]?.hasMoved) {
                    if (!tempBoardForCastleCheck[row][col + 1] && !tempBoardForCastleCheck[row][col + 2]) { 
                        if (!isSquareAttackedSimulated(row, col + 1, color === 'white' ? 'black' : 'white', gameData.piecesData) && 
                            !isSquareAttackedSimulated(row, col + 2, color === 'white' ? 'black' : 'white', gameData.piecesData)) {
                            if (isMoveLegal(pieceId, row, col + 2, true, kingsideRookId, col + 1)) {
                                legalMoves.push({ r: row, c: col + 2, isCastling: true, rookId: kingsideRookId, rookTargetCol: col + 1 });
                            }
                        }
                    }
                }
                const queensideRookCol = 0;
                const queensideRookId = tempBoardForCastleCheck[row]?.[queensideRookCol];
                 if (queensideRookId && gameData.piecesData[queensideRookId]?.type === 'rook' && !gameData.piecesData[queensideRookId]?.hasMoved) {
                    if (!tempBoardForCastleCheck[row][col - 1] && !tempBoardForCastleCheck[row][col - 2] && !tempBoardForCastleCheck[row][col - 3]) { 
                        if (!isSquareAttackedSimulated(row, col - 1, color === 'white' ? 'black' : 'white', gameData.piecesData) && 
                            !isSquareAttackedSimulated(row, col - 2, color === 'white' ? 'black' : 'white', gameData.piecesData)) {
                             if (isMoveLegal(pieceId, row, col - 2, true, queensideRookId, col - 1)) {
                                legalMoves.push({ r: row, c: col - 2, isCastling: true, rookId: queensideRookId, rookTargetCol: col - 1 });
                            }
                        }
                    }
                }
            }
            
            clearHighlights(); 
            legalMoves.forEach(move => {
                const square = boardSquares[move.r][move.c];
                square.material.color.set(squareColors.highlight);
                if (move.isCastling) {
                    square.userData.isCastling = true;
                    square.userData.rook = chessPieces[move.rookId]; 
                    square.userData.rookTargetCol = move.rookTargetCol;
                }
                highlightedSquares.push(square);
            });

            if (legalMoves.length === 0 && selectedPiece && selectedPiece.userData.id === pieceId) {
                if(statusElement) statusElement.textContent = `Selected ${type} has no legal moves.`;
                if (isKingInCheckSimulated(color, gameData.piecesData) && statusElement) statusElement.textContent += ` Your king is in check!`;
            }
        }
        
        function getAllLegalMovesForPlayerSimulated(playerColor, currentPiecesData) {
            if (!currentPiecesData) return [];
            let allMoves = [];
            for (const pieceId in currentPiecesData) {
                const pieceData = currentPiecesData[pieceId];
                if (pieceData && pieceData.color === playerColor) {
                    const potential = getPotentialMoves_Simulated_For_GetAll(pieceId, currentPiecesData); 
                    potential.forEach(move => {
                        let isCastling = false; let rookIdForCastle = null; let rookTargetColForCastle = null;
                        if (pieceData.type === 'king' && Math.abs(move.c - pieceData.col) === 2) { 
                            isCastling = true;
                            const tempBoardForCastle = buildTempBoardFromPiecesData(currentPiecesData);
                            const rookOriginalCol = move.c > pieceData.col ? 7 : 0; 
                            rookIdForCastle = tempBoardForCastle[pieceData.row]?.[rookOriginalCol];
                            if (!rookIdForCastle || !currentPiecesData[rookIdForCastle] || currentPiecesData[rookIdForCastle].type !== 'rook') isCastling = false;
                            else rookTargetColForCastle = move.c > pieceData.col ? pieceData.col + 1 : pieceData.col - 1;
                        }
                        if (isMoveLegal(pieceId, move.r, move.c, isCastling, rookIdForCastle, rookTargetColForCastle)) {
                             allMoves.push({ pieceId, r: move.r, c: move.c });
                        }
                    });
                }
            }
            return allMoves;
        }
        
        function getPotentialMoves_Simulated_For_GetAll(pieceId, currentPiecesData) { 
            const pieceData = currentPiecesData[pieceId];
            if (!pieceData) return [];
            const { row, col, type, color } = pieceData;
            let potentialMoves = [];
            const tempBoard = buildTempBoardFromPiecesData(currentPiecesData);

            if (type === 'pawn') {
                const direction = color === 'white' ? -1 : 1;
                if (isValidSquare(row + direction, col) && !tempBoard[row + direction][col]) potentialMoves.push({ r: row + direction, c: col });
                if (((color === 'white' && row === 6) || (color === 'black' && row === 1)) && isValidSquare(row + 2 * direction, col) && !tempBoard[row + 2 * direction][col] && !tempBoard[row + direction][col]) potentialMoves.push({ r: row + 2 * direction, c: col });
                for (let dc of [-1, 1]) { if (isValidSquare(row + direction, col + dc)) { const targetId = tempBoard[row + direction][col + dc]; if (targetId && currentPiecesData[targetId] && currentPiecesData[targetId].color !== color) potentialMoves.push({ r: row + direction, c: col + dc }); } }
            } else if (type === 'knight') {
                const knightMoves = [ { dr: -2, dc: -1 }, { dr: -2, dc: 1 }, { dr: -1, dc: -2 }, { dr: -1, dc: 2 }, { dr: 1, dc: -2 }, { dr: 1, dc: 2 }, { dr: 2, dc: -1 }, { dr: 2, dc: 1 }];
                knightMoves.forEach(move => { const r = row + move.dr; const c = col + move.dc; if (isValidSquare(r, c)) { const targetId = tempBoard[r][c]; if (!targetId || (currentPiecesData[targetId] && currentPiecesData[targetId].color !== color)) potentialMoves.push({ r, c }); } });
            } else if (type === 'king') {
                const kingMoves = [ { dr: -1, dc: -1 }, { dr: -1, dc: 0 }, { dr: -1, dc: 1 }, { dr: 0, dc: -1 }, { dr: 0, dc: 1 }, { dr: 1, dc: -1 }, { dr: 1, dc: 0 }, { dr: 1, dc: 1 }];
                kingMoves.forEach(move => { const r = row + move.dr; const c = col + move.dc; if (isValidSquare(r, c)) { const targetId = tempBoard[r][c]; if (!targetId || (currentPiecesData[targetId] && currentPiecesData[targetId].color !== color)) potentialMoves.push({ r, c }); } });
            } else { 
                let directions = [];
                if (type === 'rook') directions = [ {dr: 0, dc: 1}, {dr: 0, dc: -1}, {dr: 1, dc: 0}, {dr: -1, dc: 0} ];
                if (type === 'bishop') directions = [ {dr: -1, dc: -1}, {dr: -1, dc: 1}, {dr: 1, dc: -1}, {dr: 1, dc: 1} ];
                if (type === 'queen') directions = [ {dr: 0, dc: 1}, {dr: 0, dc: -1}, {dr: 1, dc: 0}, {dr: -1, dc: 0}, {dr: -1, dc: -1}, {dr: -1, dc: 1}, {dr: 1, dc: -1}, {dr: 1, dc: 1} ];
                directions.forEach(dir => {
                    for (let k = 1; k < boardSize; k++) {
                        const r = row + dir.dr * k; const c = col + dir.dc * k;
                        if (!isValidSquare(r, c)) break;
                        const targetId = tempBoard[r][c];
                        if (targetId) { if (currentPiecesData[targetId] && currentPiecesData[targetId].color !== color) potentialMoves.push({ r, c }); break; }
                        potentialMoves.push({ r, c });
                    }
                });
            }
            return potentialMoves;
        }

        async function makeMoveOnFirestore(movedPieceId, newRow, newCol, isCastling = false, rookIdToMove = null, rookTargetCol = null) { 
            if (gameOver) return;
            console.log(`[makeMoveOnFirestore] Moving ${movedPieceId} to ${newRow},${newCol}. Castling: ${isCastling}`);

            const batch = writeBatch(db);
            const updates = {}; 
            
            let tempPiecesDataForCheck = JSON.parse(JSON.stringify(gameData.piecesData));

            const pieceToMoveData = tempPiecesDataForCheck[movedPieceId]; 
            
            pieceToMoveData.row = newRow;
            pieceToMoveData.col = newCol;
            pieceToMoveData.hasMoved = true;
            
            updates[`piecesData.${movedPieceId}.row`] = newRow;
            updates[`piecesData.${movedPieceId}.col`] = newCol;
            updates[`piecesData.${movedPieceId}.hasMoved`] = true;

            const originalBoardForCaptureCheck = buildTempBoardFromPiecesData(gameData.piecesData);
            const capturedPieceIdOriginal = originalBoardForCaptureCheck[newRow][newCol];

            if (capturedPieceIdOriginal && capturedPieceIdOriginal !== movedPieceId) {
                delete tempPiecesDataForCheck[capturedPieceIdOriginal]; 
                updates[`piecesData.${capturedPieceIdOriginal}`] = deleteField(); 
                console.log(`Piece ${capturedPieceIdOriginal} captured.`);
            }
            
            if (isCastling && rookIdToMove) {
                const rookToMoveDataSim = tempPiecesDataForCheck[rookIdToMove]; 
                rookToMoveDataSim.col = rookTargetCol;
                rookToMoveDataSim.hasMoved = true;
                
                updates[`piecesData.${rookIdToMove}.col`] = rookTargetCol;
                updates[`piecesData.${rookIdToMove}.hasMoved`] = true;
                console.log(`Castling: Rook ${rookIdToMove} data updated for simulation and Firestore.`);
            }
            
            const nextPlayer = gameData.currentPlayer === 'white' ? 'black' : 'white';
            updates.currentPlayer = nextPlayer;
            updates.lastMoveTimestamp = serverTimestamp();
            
            const kingInCheckAfterMove = isKingInCheckSimulated(nextPlayer, tempPiecesDataForCheck);
            updates.check = kingInCheckAfterMove;
            updates.checkedPlayer = kingInCheckAfterMove ? nextPlayer : null;
            
            const legalMovesForNextPlayer = getAllLegalMovesForPlayerSimulated(nextPlayer, tempPiecesDataForCheck);

            if (kingInCheckAfterMove && legalMovesForNextPlayer.length === 0) {
                updates.gameOver = true;
                updates.winner = gameData.currentPlayer; 
                console.log(`Checkmate! Winner: ${updates.winner}`);
            } else if (!kingInCheckAfterMove && legalMovesForNextPlayer.length === 0) {
                updates.gameOver = true;
                updates.winner = 'draw'; 
                console.log("Stalemate! Draw.");
            } else {
                updates.gameOver = false; 
                updates.winner = null;
            }

            batch.update(gameDocRef, updates);
            try {
                await batch.commit();
                console.log("[makeMoveOnFirestore] Move committed.");
                selectedPiece = null; 
                clearHighlights();    
            } catch (error) {
                console.error("[makeMoveOnFirestore] Error committing move:", error);
                showMessage("Error making move: " + error.message + ". Please try again.");
            }
        }
        
        // Refactored interaction handler
        function handleInteraction(clientX, clientY) {
            if (gameOver || !localPlayerColor || gameData.currentPlayer !== localPlayerColor || (gameData.playerIds && gameData.playerIds[localPlayerColor] !== localPlayerAuthId) ) {
                 if (gameOver) showMessage("Game Over. No more moves allowed.");
                 else if (!localPlayerColor) showMessage("You are spectating.");
                 else if (gameData.currentPlayer !== localPlayerColor) showMessage("Not your turn.");
                return; 
            }

            const canvas = renderer.domElement;
            const rect = canvas.getBoundingClientRect();
            const x = clientX - rect.left;
            const y = clientY - rect.top;

            mouse.x = (x / canvas.clientWidth) * 2 - 1; 
            mouse.y = -(y / canvas.clientHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(scene.children, true); 
            if (intersects.length > 0) {
                let clickedObjectOrGroup = intersects[0].object;
                while (clickedObjectOrGroup.parent && !(clickedObjectOrGroup.userData.type === 'square' || clickedObjectOrGroup.userData.id)) { 
                    clickedObjectOrGroup = clickedObjectOrGroup.parent;
                }
                const userData = clickedObjectOrGroup.userData;

                if (userData.type === 'square') { 
                    if (selectedPiece && highlightedSquares.includes(clickedObjectOrGroup)) {
                        const targetRow = userData.row;
                        const targetCol = userData.col;
                        if (userData.isCastling) {
                            makeMoveOnFirestore(selectedPiece.userData.id, targetRow, targetCol, true, userData.rook.userData.id, userData.rookTargetCol);
                        } else {
                            makeMoveOnFirestore(selectedPiece.userData.id, targetRow, targetCol);
                        }
                    } else if (selectedPiece) { if(statusElement) statusElement.textContent = "Invalid move. Select a highlighted square or another piece.";}
                    else {if(statusElement) statusElement.textContent = "Select a piece first.";}
                } else if (userData.id && userData.color === localPlayerColor) { 
                    selectPiece(chessPieces[userData.id]); 
                } else if (userData.id && userData.color !== localPlayerColor && selectedPiece) { 
                     // Attempting to capture
                     // Check if the square the opponent's piece is on is a highlighted valid move
                     const opponentPieceSquare = boardSquares[userData.row][userData.col];
                     if (highlightedSquares.includes(opponentPieceSquare)) {
                        makeMoveOnFirestore(selectedPiece.userData.id, userData.row, userData.col);
                     } else {
                        if(statusElement) statusElement.textContent = "Invalid capture target.";
                     }
                }
            }
        }

        function onMouseDown(event) { 
            event.preventDefault();
            handleInteraction(event.clientX, event.clientY);
        }

        function onTouchStart(event) {
            event.preventDefault();
            if (event.touches.length > 0) {
                handleInteraction(event.touches[0].clientX, event.touches[0].clientY);
            }
        }
        
        function selectPiece(piece3D) { 
            if (selectedPiece) {
                const prevSquare = boardSquares[selectedPiece.userData.row][selectedPiece.userData.col];
                prevSquare.material.color.setHex(prevSquare.userData.originalColor);
            }
            clearHighlights(); 
            selectedPiece = piece3D; 
            const { row, col, type, color, id } = piece3D.userData; 
            const currentSquare = boardSquares[row][col];
            currentSquare.material.color.set(squareColors.selected);
            if(statusElement) statusElement.textContent = `Selected ${type} (${color}). Choose a destination.`;
            highlightValidMoves(id); 
        }

        function clearHighlights() { 
            highlightedSquares.forEach(sq => {
                sq.material.color.setHex(sq.userData.originalColor);
                delete sq.userData.isCastling; delete sq.userData.rook; delete sq.userData.rookTargetCol;
            }); 
            highlightedSquares = []; 
        }


        function disposePiece(piece) { 
            if (!piece) return;
            if (piece.children && piece.children.length > 0) {
                piece.children.forEach(child => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) { if (Array.isArray(child.material)) child.material.forEach(mat => mat.dispose()); else child.material.dispose(); }
                });
            } else {
                if (piece.geometry) piece.geometry.dispose();
                if (piece.material) { if (Array.isArray(piece.material)) piece.material.forEach(mat => mat.dispose()); else piece.material.dispose(); }
            }
        }
        function triggerConfetti() { 
             if (!scene) return;
            for (let i = 0; i < 200; i++) {
                const geometry = new THREE.SphereGeometry(0.3, 8, 8); 
                const material = new THREE.MeshBasicMaterial({ color: confettiColors[Math.floor(Math.random() * confettiColors.length)] });
                const particle = new THREE.Mesh(geometry, material);
                particle.position.set( (Math.random() - 0.5) * 150, 100 + (Math.random() - 0.5) * 20, (Math.random() - 0.5) * 150 );
                particle.velocity = new THREE.Vector3( (Math.random() - 0.5) * 0.5, -Math.random() * 0.5 - 0.2, (Math.random() - 0.5) * 0.5 );
                particle.life = 200 + Math.random() * 100; 
                scene.add(particle); confettiParticles.push(particle);
            }
        }
        function animateConfetti() { 
            for (let i = confettiParticles.length - 1; i >= 0; i--) {
                const particle = confettiParticles[i]; particle.position.add(particle.velocity); particle.life--;
                if (particle.life <= 0) { scene.remove(particle); disposePiece(particle); confettiParticles.splice(i, 1); }
            }
        }
        function animate() { 
            requestAnimationFrame(animate); 
            if(controls) controls.update(); 
            if(renderer && scene && camera) renderer.render(scene, camera); 
            if (confettiParticles.length > 0) animateConfetti();
        }

    </script>
</body>
</html>
