<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Chess Game - Multiplayer</title>
    <style>
        body { margin: 0; font-family: 'Inter', sans-serif; background-color: #1a1a1a; color: #e0e0e0; overflow: hidden; display: flex; justify-content: center; align-items: center; height: 100vh; }
        #gameContainer { position: relative; width: 100%; height: 100%; }
        #info { position: absolute; top: 10px; left: 50%; transform: translateX(-50%); width: 90%; max-width: 600px; text-align: center; z-index: 100; padding: 10px; background-color: rgba(0,0,0,0.6); border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.5); }
        #playerInfo { margin-bottom: 5px; font-size: 0.9em;}
        #status { font-size: 1em; margin-top:5px;}
        #messageBox { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: rgba(30, 30, 30, 0.97); color: white; padding: 25px; border-radius: 12px; box-shadow: 0 5px 20px rgba(0,0,0,0.6); z-index: 1000; display: none; text-align: center; border: 1px solid #444; }
        #messageBox button { background-color: #007bff; color: white; border: none; padding: 12px 20px; border-radius: 6px; cursor: pointer; margin-top: 20px; font-size: 1em; transition: background-color 0.3s; }
        #messageBox button:hover { background-color: #0056b3; }
        canvas { display: block; }
        #nameEntryModal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.8); z-index: 2000; display: flex; justify-content: center; align-items: center; }
        #nameEntryBox { background-color: #2c2c2c; padding: 30px; border-radius: 10px; text-align: center; box-shadow: 0 0 20px rgba(0,0,0,0.5); }
        #nameEntryBox h2 { margin-top: 0; color: #f0f0f0; }
        #nameInput { padding: 10px; margin: 10px 0; border-radius: 5px; border: 1px solid #555; background-color: #333; color: #fff; width: 80%; }
        #joinGameButton { background-color: #28a745; color: white; padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer; }
        #joinGameButton:hover { background-color: #1e7e34; }
        .confetti { position: absolute; width: 10px; height: 10px; background-color: red; opacity: 0.7; border-radius: 50%; }
    </style>
    <script src="https://cdn.tailwindcss.com"></script>
    <script async src="https://ga.jspm.io/npm:es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.138.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.138.0/examples/jsm/"
        }
    }
    </script>
</head>
<body>
    <div id="nameEntryModal">
        <div id="nameEntryBox">
            <h2>Enter Your Name</h2>
            <input type="text" id="nameInput" placeholder="Player Name">
            <button id="joinGameButton">Join Game</button>
        </div>
    </div>

    <div id="gameContainer" style="display: none;">
        <div id="info">
            <h1 class="text-2xl font-bold">3D Chess - Multiplayer</h1>
            <div id="playerInfo">Your Name: <span id="localPlayerName"></span> (<span id="localPlayerColor"></span>)</div>
            <p id="turnInfo" class="text-lg">Loading game...</p>
            <p id="status" class="text-md">Waiting for players...</p>
        </div>
        <div id="messageBox">
            <p id="messageText"></p>
            <button id="messageButton">OK</button>
        </div>
        </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, getDoc, onSnapshot, updateDoc, serverTimestamp, writeBatch } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- Firebase Setup ---
        // IMPORTANT: Replace this with your actual Firebase config object!
        const firebaseConfig = {
            apiKey: "AIzaSyCdvtD3EZ676BvyI9SWSity90GF4rSu4I0", // Replace
            authDomain: "chess-8c8fe.firebaseapp.com", // Replace
            projectId: "chess-8c8fe", // Replace
            storageBucket: "chess-8c8fe.firebasestorage.app", // Replace
            messagingSenderId: "165910435435", // Replace
            appId: "1:165910435435:web:254d1a99e528b86458432e", // Replace
            measurementId: "G-DJV31JNSD8" // Optional, but good to have
        };
        // const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : { apiKey: "YOUR_API_KEY", authDomain: "YOUR_AUTH_DOMAIN", projectId: "YOUR_PROJECT_ID" }; // Fallback for local dev
        
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        const appId = firebaseConfig.projectId || 'default-chess-app'; // Use projectId for appId context
        const gameId = 'defaultPublicGame'; 
        const gameDocRef = doc(db, `/artifacts/${appId}/public/data/chessGames/${gameId}`);

        let localPlayerAuthId = null;
        let localPlayerName = ''; // Initialized as empty
        let localPlayerColor = null; 
        let unsubscribeGameListener = null;
        let gameInitialized = false; // Flag to prevent multiple initializations


        // --- Scene Setup ---
        let scene, camera, renderer, controls;
        let raycaster, mouse;

        // --- Game State (local copy, synced from Firestore) ---
        const boardSize = 8;
        const squareSize = 10; 
        const pieceElevation = 0.5;
        let boardSquares = []; 
        let chessPieces = {}; 
        let gameData = {}; 
        let selectedPiece = null; 
        let highlightedSquares = []; 
        let gameOver = false; 

        const pieceColors = { white: 0xdddddd, black: 0x222222 };
        const squareColors = { light: 0xDEB887, dark: 0x8B4513, highlight: 0x32CD32, selected: 0xFFD700 };

        // --- DOM Elements ---
        const turnInfoElement = document.getElementById('turnInfo');
        const statusElement = document.getElementById('status');
        const messageBox = document.getElementById('messageBox');
        const messageText = document.getElementById('messageText');
        const messageButton = document.getElementById('messageButton');
        const nameEntryModal = document.getElementById('nameEntryModal');
        const nameInput = document.getElementById('nameInput');
        const joinGameButton = document.getElementById('joinGameButton');
        const gameContainer = document.getElementById('gameContainer');
        const localPlayerNameSpan = document.getElementById('localPlayerName');
        const localPlayerColorSpan = document.getElementById('localPlayerColor');

        // --- Confetti ---
        let confettiParticles = [];
        const confettiColors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff, 0x00ffff];


        // --- Event Listeners ---
        messageButton.addEventListener('click', () => { messageBox.style.display = 'none'; });
        joinGameButton.addEventListener('click', handleJoinGame);
        
        onAuthStateChanged(auth, async (user) => {
            console.log(`[onAuthStateChanged] Fired. User:`, user);
            if (user) {
                localPlayerAuthId = user.uid;
                console.log(`[onAuthStateChanged] localPlayerAuthId set to: '${localPlayerAuthId}'`);

                // If localPlayerName is already set (meaning handleJoinGame has run and set the name),
                // and the game hasn't been initialized for this session yet, proceed to setup.
                if (localPlayerName && !gameInitialized) {
                    console.log(`[onAuthStateChanged] User authenticated and localPlayerName ('${localPlayerName}') is set. Proceeding to setupGameSession.`);
                    await setupGameSession();
                } else if (gameInitialized) {
                    console.log(`[onAuthStateChanged] User authenticated, but game already initialized. localPlayerName: '${localPlayerName}'`);
                    // Potentially re-verify player's role if needed, or re-establish listener if lost
                    if(!unsubscribeGameListener && scene) listenToGameUpdates(); // Re-attach listener if scene exists (e.g. after refresh and re-auth)
                }
                 else {
                    console.warn(`[onAuthStateChanged] User authenticated, but localPlayerName ('${localPlayerName}') is not set yet OR game already initialized.`);
                }
            } else {
                console.log("[onAuthStateChanged] No user / signed out.");
                localPlayerAuthId = null;
                localPlayerName = ''; // Reset name on sign out
                localPlayerColor = null;
                gameInitialized = false; // Reset init flag
                
                // Handle sign-out: show name modal again, clear game state.
                nameEntryModal.style.display = 'flex';
                gameContainer.style.display = 'none';
                if(unsubscribeGameListener) {
                    unsubscribeGameListener();
                    unsubscribeGameListener = null;
                }
                // Clear local game vars if needed, hide UI elements
                localPlayerNameSpan.textContent = "";
                localPlayerColorSpan.textContent = "";
                turnInfoElement.textContent = "Disconnected.";
                statusElement.textContent = "Please enter your name to join.";
            }
        });

        async function handleJoinGame() {
            const nameFromInput = nameInput.value.trim();
            console.log(`[handleJoinGame] Attempting to join with name: '${nameFromInput}'`);

            if (!nameFromInput) {
                alert("Please enter your name.");
                return;
            }
            localPlayerName = nameFromInput; // Set global localPlayerName FIRST

            nameEntryModal.style.display = 'none';
            gameContainer.style.display = 'block';
            statusElement.textContent = "Authenticating...";
            localPlayerNameSpan.textContent = localPlayerName; // Optimistically update UI for name

            try {
                // Check if already signed in from this session (onAuthStateChanged might handle this too)
                if (auth.currentUser && auth.currentUser.uid) {
                    localPlayerAuthId = auth.currentUser.uid; // Ensure it's set
                    console.log(`[handleJoinGame] User already authenticated (UID: ${localPlayerAuthId}). localPlayerName is '${localPlayerName}'. Proceeding to setupGameSession.`);
                    if (!gameInitialized) await setupGameSession(); // Call if name is set and auth is confirmed
                } else if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) { // For specific environments
                    console.log(`[handleJoinGame] Attempting signInWithCustomToken. localPlayerName is '${localPlayerName}'.`);
                    await signInWithCustomToken(auth, __initial_auth_token);
                    // onAuthStateChanged will then fire. Since localPlayerName is now set, it will call setupGameSession.
                } else {
                    console.log(`[handleJoinGame] Attempting signInAnonymously. localPlayerName is '${localPlayerName}'.`);
                    await signInAnonymously(auth);
                    // onAuthStateChanged will then fire. Since localPlayerName is now set, it will call setupGameSession.
                }
            } catch (error) {
                console.error("[handleJoinGame] Error during auth:", error);
                showMessage("Authentication error. Please refresh and try again.");
                nameEntryModal.style.display = 'flex'; // Show name entry again
                gameContainer.style.display = 'none';
                localPlayerName = ''; // Reset name if join failed
                localPlayerNameSpan.textContent = "";
            }
        }
        
        async function setupGameSession() {
            if (gameInitialized) {
                console.log("[setupGameSession] Already initialized, skipping.");
                return;
            }
            console.log(`[setupGameSession] Entered. localPlayerAuthId: '${localPlayerAuthId}', localPlayerName: '${localPlayerName}'`);
            if (!localPlayerAuthId || !localPlayerName) { 
                console.error(`[setupGameSession] Returning early. AuthId: ${localPlayerAuthId}, Name: ${localPlayerName}. This indicates a problem in the flow.`);
                statusElement.textContent = "Error: Missing player details. Please refresh.";
                // Don't set gameInitialized = true here
                return;
            }
            
            gameInitialized = true; // Set flag to prevent re-entry

            localPlayerNameSpan.textContent = localPlayerName; // Ensure name is displayed
            statusElement.textContent = "Connecting to game room...";

            try {
                const gameSnap = await getDoc(gameDocRef);
                let players = gameSnap.exists() ? gameSnap.data().players || {} : {};
                let playerIds = gameSnap.exists() ? gameSnap.data().playerIds || {} : {};
                
                let assignedColorThisSession = null;

                // Check if this authId already has a color
                if (playerIds.white === localPlayerAuthId) assignedColorThisSession = 'white';
                else if (playerIds.black === localPlayerAuthId) assignedColorThisSession = 'black';
                
                // If still no color, try to assign a new one
                if (!assignedColorThisSession) {
                    if (!playerIds.white) { 
                        assignedColorThisSession = 'white';
                    } else if (!playerIds.black) { 
                        assignedColorThisSession = 'black';
                    }
                }

                localPlayerColor = assignedColorThisSession;
                
                if (localPlayerColor) { // If successfully assigned a color (or re-joined)
                    players[localPlayerColor] = localPlayerName; // Update name in case it changed
                    playerIds[localPlayerColor] = localPlayerAuthId; // Ensure ID is correct
                    localPlayerColorSpan.textContent = localPlayerColor;
                    console.log(`[setupGameSession] Player ${localPlayerName} (${localPlayerAuthId}) assigned/confirmed as ${localPlayerColor}`);
                } else {
                    localPlayerColorSpan.textContent = "Spectator";
                    showMessage("Game is currently full or error assigning color. You are spectating.");
                    statusElement.textContent = "Spectating.";
                    console.log(`[setupGameSession] Player ${localPlayerName} could not be assigned a color. Spectating.`);
                }

                if (!gameSnap.exists() && localPlayerColor) { 
                    console.log(`[setupGameSession] Game doc doesn't exist, creating with player ${localPlayerColor}: ${localPlayerName}`);
                    const initialBoardStateData = setupInitialBoardState(); 
                    const initialGameData = {
                        boardState: initialBoardStateData.board, 
                        piecesData: initialBoardStateData.pieces, 
                        currentPlayer: 'white',
                        players: players, 
                        playerIds: playerIds, 
                        gameOver: false, winner: null, lastMoveTimestamp: serverTimestamp(),
                        check: false, checkedPlayer: null
                    };
                    await setDoc(gameDocRef, initialGameData);
                } else if (localPlayerColor) { 
                    console.log(`[setupGameSession] Updating game doc for player ${localPlayerColor}: ${localPlayerName}`);
                    await updateDoc(gameDocRef, {
                        // Only update player's own slot to avoid race conditions if two join simultaneously
                        // More robust would be a transaction or cloud function for initial player slotting.
                        [`players.${localPlayerColor}`]: localPlayerName, 
                        [`playerIds.${localPlayerColor}`]: localPlayerAuthId,
                        // If players object itself doesn't exist, this might need to set the whole players object
                        // For simplicity, assuming players object exists if gameSnap exists and playerIds are checked
                    });
                }

                if (!scene) { 
                    console.log(`[setupGameSession] Initializing Three.js scene.`);
                    initThreeJS(); 
                } else { 
                     if (localPlayerColor) setCameraForPlayer(localPlayerColor);
                }
                listenToGameUpdates(); // Start or re-start listener

            } catch (error) {
                console.error("[setupGameSession] Error during Firestore operations:", error);
                showMessage("Failed to connect to game room. Please try again.");
                gameInitialized = false; // Allow re-init on next attempt
                nameEntryModal.style.display = 'flex'; 
                gameContainer.style.display = 'none';
                localPlayerNameSpan.textContent = "";
                localPlayerColorSpan.textContent = "";
            }
        }


        function listenToGameUpdates() { /* ... same as before ... */ 
            if (unsubscribeGameListener) unsubscribeGameListener(); 
            console.log("[listenToGameUpdates] Attaching Firestore listener.");
            unsubscribeGameListener = onSnapshot(gameDocRef, (docSnap) => {
                console.log("[onSnapshot] Game data received from Firestore:", docSnap.exists() ? docSnap.data() : "No document");
                if (docSnap.exists()) {
                    gameData = docSnap.data();
                    gameOver = gameData.gameOver; 
                    updateLocalBoardFromFirestore(gameData.boardState, gameData.piecesData);
                    updateTurnInfo();
                    
                    if (gameData.gameOver && gameData.winner) {
                        if (gameData.winner === 'draw') {
                             statusElement.textContent = "Stalemate! The game is a draw.";
                             showMessage("Stalemate! It's a draw.");
                        } else {
                            const winnerName = gameData.players[gameData.winner] || gameData.winner;
                            statusElement.textContent = `Checkmate! ${winnerName} wins!`;
                            showMessage(`Checkmate! ${winnerName} wins!`);
                            if ((localPlayerColor && gameData.winner === localPlayerColor) || (gameData.players[gameData.winner] === localPlayerName)) {
                                triggerConfetti();
                            }
                        }
                    } else if (gameData.check && gameData.checkedPlayer) {
                        const checkedPlayerName = gameData.players[gameData.checkedPlayer] || gameData.checkedPlayer;
                        const message = `${checkedPlayerName}'s King is in Check!`;
                        if (gameData.checkedPlayer === localPlayerColor) {
                            statusElement.textContent = `Your King is in Check!`;
                            showMessage(`Your King is in Check!`);
                         } else {
                            statusElement.textContent = message;
                         }
                    }

                } else {
                    statusElement.textContent = "Game data not found. Waiting for game to start...";
                     if (!localPlayerColor && localPlayerName) { // User entered name but game doc disappeared
                        nameEntryModal.style.display = 'flex';
                        gameContainer.style.display = 'none';
                        showMessage("Game room closed or not found. Please try joining again.");
                        gameInitialized = false;
                    }
                }
            }, (error) => {
                console.error("[onSnapshot] Error listening to game updates:", error);
                showMessage("Connection to game lost. Please refresh.");
            });
        }

        function updateLocalBoardFromFirestore(firestoreBoardState, firestorePiecesData) { /* ... same as before ... */ 
            if (!scene) { console.warn("[updateLocalBoardFromFirestore] Scene not ready."); return; }

            for (const pieceId in chessPieces) {
                if(chessPieces[pieceId]) scene.remove(chessPieces[pieceId]);
                disposePiece(chessPieces[pieceId]);
            }
            chessPieces = {}; 
            boardState = new Array(boardSize).fill(null).map(() => new Array(boardSize).fill(null));

            if (firestorePiecesData) {
                for (const pieceId in firestorePiecesData) {
                    const data = firestorePiecesData[pieceId];
                    if (!data) { // Piece might have been captured (set to null)
                        console.log(`Piece data for ${pieceId} is null, likely captured.`);
                        continue;
                    }
                    let piece3D;
                    if (data.type === 'pawn') piece3D = createPawn(data.color);
                    else if (data.type === 'rook') piece3D = createRook(data.color);
                    else if (data.type === 'knight') piece3D = createKnight(data.color);
                    else if (data.type === 'bishop') piece3D = createBishop(data.color);
                    else if (data.type === 'queen') piece3D = createQueen(data.color);
                    else if (data.type === 'king') piece3D = createKing(data.color);
                    
                    if (piece3D) {
                        piece3D.userData = { ...data, id: pieceId }; 
                        const pieceY = piece3D.userData.totalHeight ? piece3D.userData.totalHeight / 2 + pieceElevation : squareSize * 0.5 + pieceElevation;
                        piece3D.position.set( (data.col - boardSize / 2 + 0.5) * squareSize, pieceY, (data.row - boardSize / 2 + 0.5) * squareSize );
                        if (data.color === 'black' && data.type !== 'pawn') piece3D.rotation.y = Math.PI;
                        scene.add(piece3D);
                        chessPieces[pieceId] = piece3D;
                        if (isValidSquare(data.row, data.col)) {
                           boardState[data.row][data.col] = { piece: piece3D, ...data }; 
                        }
                    }
                }
            }
            if (localPlayerColor && camera) { // camera might not be init'd if scene isn't
                setCameraForPlayer(localPlayerColor);
            } else if (!localPlayerColor && camera) { // Default for spectator
                camera.position.set(0, 90, 90); camera.lookAt(0,0,0); if(controls) controls.update();
            }
        }
        
        function setCameraForPlayer(playerColor) { /* ... same as before ... */ 
            if (!camera) return;
            if (playerColor === 'white') { camera.position.set(0, 90, 90); } 
            else if (playerColor === 'black') { camera.position.set(0, 90, -90); }
            camera.lookAt(0, 0, 0);
            if (controls) controls.update();
            camera.userData.povSet = true; camera.userData.playerColor = playerColor;
        }

        function updateTurnInfo() { /* ... same as before, ensure gameData.players is checked ... */ 
            if (!gameData || Object.keys(gameData).length === 0) {
                turnInfoElement.textContent = "Loading game data..."; return;
            }
            if (gameData.gameOver) { return; } // Message handled by gameOver logic
            if (gameData.currentPlayer) {
                const currentPlayerName = gameData.players?.[gameData.currentPlayer] || gameData.currentPlayer.toUpperCase();
                turnInfoElement.textContent = `${currentPlayerName}'s Turn (${gameData.currentPlayer})`;
                if (gameData.currentPlayer === localPlayerColor) {
                    statusElement.textContent = "Your turn. Select a piece.";
                } else {
                    statusElement.textContent = `Waiting for ${currentPlayerName}...`;
                }
            } else {
                turnInfoElement.textContent = "Waiting for player assignment...";
            }
        }

        function initThreeJS() { /* ... same as before ... */ 
            scene = new THREE.Scene(); scene.background = new THREE.Color(0x667788);
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 2000);
            // Default camera, will be adjusted by setCameraForPlayer
            camera.position.set(0,90,90); camera.lookAt(0,0,0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight); renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            gameContainer.appendChild(renderer.domElement); 
            
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8); scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0); 
            directionalLight.position.set(60, 120, 70); directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048; directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 50; directionalLight.shadow.camera.far = 300;
            directionalLight.shadow.camera.left = -100; directionalLight.shadow.camera.right = 100;
            directionalLight.shadow.camera.top = 100; directionalLight.shadow.camera.bottom = -100;
            scene.add(directionalLight);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; controls.dampingFactor = 0.05; controls.screenSpacePanning = false;
            controls.minDistance = 30; controls.maxDistance = 250; controls.maxPolarAngle = Math.PI / 2 - 0.03; 
            raycaster = new THREE.Raycaster(); mouse = new THREE.Vector2();
            createChessboard(); 
            
            window.addEventListener('resize', onWindowResize);
            renderer.domElement.addEventListener('mousedown', onMouseDown, false);
            if(!gameData.gameOver) animate(); // Only start animation loop if game not over from start
        }

        // --- Piece Creation Functions (ensure they have userData.totalHeight) ---
        function createPawn(color) { /* ... same as before ... */ 
            const group = new THREE.Group(); const material = new THREE.MeshStandardMaterial({ color: pieceColors[color], metalness: 0.5, roughness: 0.4 });
            const baseRadius = squareSize * 0.22; const midRadius = squareSize * 0.18; const headRadius = squareSize * 0.2;
            const baseHeight = squareSize * 0.15; const stemHeight = squareSize * 0.3;
            const baseGeo = new THREE.CylinderGeometry(baseRadius, baseRadius, baseHeight, 24); const base = new THREE.Mesh(baseGeo, material); base.castShadow = true; group.add(base);
            const stemGeo = new THREE.CylinderGeometry(midRadius, baseRadius * 0.8, stemHeight, 24); const stem = new THREE.Mesh(stemGeo, material); stem.position.y = baseHeight / 2 + stemHeight / 2; stem.castShadow = true; group.add(stem);
            const headGeo = new THREE.SphereGeometry(headRadius, 24, 16); const head = new THREE.Mesh(headGeo, material); head.position.y = baseHeight / 2 + stemHeight + headRadius * 0.7; head.castShadow = true; group.add(head);
            group.userData = { type: 'pawn', color: color, totalHeight: baseHeight + stemHeight + headRadius * 1.4 }; return group;
        }
        function createRook(color) { /* ... same as before ... */ 
            const group = new THREE.Group(); const material = new THREE.MeshStandardMaterial({ color: pieceColors[color], metalness: 0.6, roughness: 0.3 });
            const baseRadius = squareSize * 0.3; const midRadius = squareSize * 0.25; const topRadius = squareSize * 0.28;
            const baseHeight = squareSize * 0.2; const shaftHeight = squareSize * 0.5; const topHeight = squareSize * 0.25; const crenellationHeight = squareSize * 0.2; const crenellationWidth = squareSize * 0.15;
            const baseGeo = new THREE.CylinderGeometry(baseRadius * 1.1, baseRadius, baseHeight, 32); const base = new THREE.Mesh(baseGeo, material); base.castShadow = true; group.add(base);
            const shaftGeo = new THREE.CylinderGeometry(midRadius, midRadius, shaftHeight, 32); const shaft = new THREE.Mesh(shaftGeo, material); shaft.position.y = baseHeight / 2 + shaftHeight / 2; shaft.castShadow = true; group.add(shaft);
            const topGeo_ = new THREE.CylinderGeometry(topRadius, topRadius * 0.9, topHeight, 32); const top_ = new THREE.Mesh(topGeo_, material); top_.position.y = baseHeight / 2 + shaftHeight + topHeight / 2; top_.castShadow = true; group.add(top_);
            const numCrenellations = 6; for (let i = 0; i < numCrenellations; i++) { const angle = (i / numCrenellations) * Math.PI * 2; const crenGeo = new THREE.BoxGeometry(crenellationWidth, crenellationHeight, crenellationWidth * 0.8); const cren = new THREE.Mesh(crenGeo, material); cren.position.set( Math.cos(angle) * (topRadius - crenellationWidth * 0.3), baseHeight / 2 + shaftHeight + topHeight + crenellationHeight / 2 - 0.05, Math.sin(angle) * (topRadius - crenellationWidth * 0.3)); cren.lookAt(0, cren.position.y, 0); cren.rotation.y += Math.PI / 2; cren.castShadow = true; group.add(cren); }
            group.userData = { type: 'rook', color: color, hasMoved: false, totalHeight: baseHeight + shaftHeight + topHeight + crenellationHeight }; return group;
        }
        function createKnight(color) { /* ... same as before ... */
            const group = new THREE.Group(); const material = new THREE.MeshStandardMaterial({ color: pieceColors[color], metalness: 0.5, roughness: 0.4 });
            const baseWidth = squareSize * 0.35; const baseHeight = squareSize * 0.2; const bodyHeight = squareSize * 0.4; const bodyWidth = squareSize * 0.25; const bodyDepth = squareSize * 0.3; const neckRadius = squareSize * 0.1; const neckHeight = squareSize * 0.3; const headLength = squareSize * 0.4; const headWidth = squareSize * 0.2; const headHeightVal = squareSize * 0.25;
            const baseGeo = new THREE.CylinderGeometry(baseWidth, baseWidth*0.8, baseHeight, 32); const base = new THREE.Mesh(baseGeo, material); base.castShadow = true; group.add(base);
            const bodyGeo = new THREE.BoxGeometry(bodyWidth, bodyHeight, bodyDepth); const body = new THREE.Mesh(bodyGeo, material); body.position.y = baseHeight/2 + bodyHeight/2; body.rotation.y = Math.PI / 12; body.castShadow = true; group.add(body);
            const neckGeo = new THREE.CylinderGeometry(neckRadius, neckRadius * 0.8, neckHeight, 16); const neck = new THREE.Mesh(neckGeo, material); neck.position.set(bodyWidth * 0.1, baseHeight/2 + bodyHeight + neckHeight * 0.4, bodyDepth * 0.1); neck.rotation.z = Math.PI / 6; neck.rotation.x = -Math.PI / 12; neck.castShadow = true; group.add(neck);
            const headGeo = new THREE.BoxGeometry(headWidth, headHeightVal, headLength); const head = new THREE.Mesh(headGeo, material); head.position.set( neck.position.x + Math.sin(neck.rotation.z) * neckHeight * 0.5, neck.position.y + Math.cos(neck.rotation.z) * neckHeight * 0.5 - headHeightVal*0.1, neck.position.z + headLength * 0.3 ); head.rotation.z = Math.PI / 5; head.castShadow = true; group.add(head);
            for(let i=0; i<3; i++){ const maneGeo = new THREE.BoxGeometry(squareSize*0.05, squareSize*0.15, squareSize*0.05); const manePart = new THREE.Mesh(maneGeo, material); manePart.position.set( neck.position.x - Math.sin(neck.rotation.z) * (neckHeight * 0.2 * i), neck.position.y + Math.cos(neck.rotation.z) * (neckHeight * 0.2 * i) + squareSize*0.07, neck.position.z - squareSize*0.05); manePart.rotation.z = Math.PI / 6; group.add(manePart); }
            group.userData = { type: 'knight', color: color, totalHeight: baseHeight + bodyHeight + neckHeight }; return group;
        }
        function createBishop(color) { /* ... same as before ... */ 
            const group = new THREE.Group(); const material = new THREE.MeshStandardMaterial({ color: pieceColors[color], metalness: 0.5, roughness: 0.4 });
            const baseRadius = squareSize * 0.28; const midRadius = squareSize * 0.2; const headRadius = squareSize * 0.22; const baseHeight = squareSize * 0.2; const stemHeight = squareSize * 0.5; const headHeight = squareSize * 0.4;
            const baseGeo = new THREE.CylinderGeometry(baseRadius, baseRadius * 0.9, baseHeight, 32); const base = new THREE.Mesh(baseGeo, material); base.castShadow = true; group.add(base);
            const stemGeo = new THREE.CylinderGeometry(midRadius * 0.8, midRadius, stemHeight, 32); const stem = new THREE.Mesh(stemGeo, material); stem.position.y = baseHeight / 2 + stemHeight / 2; stem.castShadow = true; group.add(stem);
            const mitreGeo = new THREE.ConeGeometry(headRadius, headHeight, 32); const mitre = new THREE.Mesh(mitreGeo, material); mitre.position.y = baseHeight / 2 + stemHeight + headHeight / 2; mitre.castShadow = true; group.add(mitre);
            const topSphereGeo = new THREE.SphereGeometry(squareSize * 0.07, 16, 16); const topSphere = new THREE.Mesh(topSphereGeo, material); topSphere.position.y = baseHeight / 2 + stemHeight + headHeight + squareSize * 0.03; topSphere.castShadow = true; group.add(topSphere);
            group.userData = { type: 'bishop', color: color, totalHeight: baseHeight + stemHeight + headHeight + squareSize * 0.07 }; return group;
        }
        function createQueen(color) { /* ... same as before ... */ 
            const group = new THREE.Group(); const material = new THREE.MeshStandardMaterial({ color: pieceColors[color], metalness: 0.7, roughness: 0.2 });
            const baseRadius = squareSize * 0.32; const midSectionRadius = squareSize * 0.22; const crownBaseRadius = squareSize * 0.28; const baseHeight = squareSize * 0.25; const stemHeight = squareSize * 0.4; const crownBaseHeight = squareSize * 0.15; const crownPointHeight = squareSize * 0.25;
            const baseGeo = new THREE.CylinderGeometry(baseRadius, baseRadius * 0.85, baseHeight, 32); const base = new THREE.Mesh(baseGeo, material); base.castShadow = true; group.add(base);
            const stemGeo = new THREE.CylinderGeometry(midSectionRadius * 0.8, midSectionRadius, stemHeight, 32); const stem = new THREE.Mesh(stemGeo, material); stem.position.y = baseHeight / 2 + stemHeight / 2; stem.castShadow = true; group.add(stem);
            const crownBaseGeo_ = new THREE.CylinderGeometry(crownBaseRadius, crownBaseRadius * 1.1, crownBaseHeight, 32); const crownBase_ = new THREE.Mesh(crownBaseGeo_, material); crownBase_.position.y = baseHeight / 2 + stemHeight + crownBaseHeight / 2; crownBase_.castShadow = true; group.add(crownBase_);
            const numCrownPoints = 7; for (let i = 0; i < numCrownPoints; i++) { const angle = (i / numCrownPoints) * Math.PI * 2; const pointGeo = new THREE.ConeGeometry(squareSize * 0.06, crownPointHeight, 8); const point = new THREE.Mesh(pointGeo, material); point.position.set( Math.cos(angle) * (crownBaseRadius * 0.9), baseHeight / 2 + stemHeight + crownBaseHeight + crownPointHeight * 0.4, Math.sin(angle) * (crownBaseRadius * 0.9)); point.castShadow = true; group.add(point); }
            const jewelGeo = new THREE.SphereGeometry(squareSize * 0.1, 16, 16); const jewel = new THREE.Mesh(jewelGeo, material); jewel.position.y = baseHeight / 2 + stemHeight + crownBaseHeight + crownPointHeight * 0.6; jewel.castShadow = true; group.add(jewel);
            group.userData = { type: 'queen', color: color, totalHeight: baseHeight + stemHeight + crownBaseHeight + crownPointHeight }; return group;
        }
        function createKing(color) { /* ... same as before ... */ 
            const group = new THREE.Group(); const material = new THREE.MeshStandardMaterial({ color: pieceColors[color], metalness: 0.7, roughness: 0.2 });
            const baseRadius = squareSize * 0.33; const midSectionRadius = squareSize * 0.25; const topSectionRadius = squareSize * 0.28; const baseHeight = squareSize * 0.3; const stemHeight = squareSize * 0.5; const topHeight = squareSize * 0.2; const crossBarLength = squareSize * 0.25; const crossBarThickness = squareSize * 0.07; const crossHeight = squareSize * 0.3;
            const baseGeo = new THREE.CylinderGeometry(baseRadius, baseRadius * 0.9, baseHeight, 32); const base = new THREE.Mesh(baseGeo, material); base.castShadow = true; group.add(base);
            const stemGeo = new THREE.CylinderGeometry(midSectionRadius * 0.9, midSectionRadius, stemHeight, 32); const stem = new THREE.Mesh(stemGeo, material); stem.position.y = baseHeight / 2 + stemHeight / 2; stem.castShadow = true; group.add(stem);
            const topGeo_ = new THREE.CylinderGeometry(topSectionRadius, topSectionRadius * 0.85, topHeight, 32); const topSection_ = new THREE.Mesh(topGeo_, material); topSection_.position.y = baseHeight / 2 + stemHeight + topHeight / 2; topSection_.castShadow = true; group.add(topSection_);
            const crossYPos = baseHeight / 2 + stemHeight + topHeight + crossHeight / 2 - crossBarThickness;
            const vBarGeo = new THREE.BoxGeometry(crossBarThickness, crossHeight, crossBarThickness); const vBar = new THREE.Mesh(vBarGeo, material); vBar.position.y = crossYPos; vBar.castShadow = true; group.add(vBar);
            const hBarGeo = new THREE.BoxGeometry(crossBarLength, crossBarThickness, crossBarThickness); const hBar = new THREE.Mesh(hBarGeo, material); hBar.position.y = crossYPos + crossHeight * 0.1; hBar.castShadow = true; group.add(hBar);
            group.userData = { type: 'king', color: color, hasMoved: false, totalHeight: baseHeight + stemHeight + topHeight + crossHeight }; return group;
        }
        
        function setupInitialBoardState() { /* ... same as before ... */ 
            let initialBoard = new Array(boardSize).fill(null).map(() => new Array(boardSize).fill(null));
            let initialPiecesData = {};
            function addInitialPiece(type, color, row, col, idSuffix) { const pieceId = `${type}_${color[0]}_${idSuffix}`; const pieceData = { type, color, row, col, hasMoved: false, id: pieceId }; initialBoard[row][col] = pieceId; initialPiecesData[pieceId] = pieceData; }
            for (let i = 0; i < boardSize; i++) addInitialPiece('pawn', 'white', 6, i, i);
            let wCol = 0; addInitialPiece('rook', 'white', 7, wCol++, '0'); addInitialPiece('knight', 'white', 7, wCol++, '0'); addInitialPiece('bishop', 'white', 7, wCol++, '0'); addInitialPiece('queen', 'white', 7, wCol++, '0'); addInitialPiece('king', 'white', 7, wCol++, '0'); addInitialPiece('bishop', 'white', 7, wCol++, '1'); addInitialPiece('knight', 'white', 7, wCol++, '1'); addInitialPiece('rook', 'white', 7, wCol++, '1');
            for (let i = 0; i < boardSize; i++) addInitialPiece('pawn', 'black', 1, i, i);
            let bCol = 0; addInitialPiece('rook', 'black', 0, bCol++, '0'); addInitialPiece('knight', 'black', 0, bCol++, '0'); addInitialPiece('bishop', 'black', 0, bCol++, '0'); addInitialPiece('queen', 'black', 0, bCol++, '0'); addInitialPiece('king', 'black', 0, bCol++, '0'); addInitialPiece('bishop', 'black', 0, bCol++, '1'); addInitialPiece('knight', 'black', 0, bCol++, '1'); addInitialPiece('rook', 'black', 0, bCol++, '1');
            return { board: initialBoard, pieces: initialPiecesData };
        }

        // --- All other game logic functions (selectPiece, highlightValidMoves, movePieceOnFirestore, etc.) ---
        // --- should remain largely the same as the previous multiplayer version, ---
        // --- ensuring they use gameData.piecesData and gameData.boardState for their logic. ---
        // --- Make sure isMoveLegal, isSquareAttackedSimulated, isKingInCheckSimulated, ---
        // --- getAllLegalMovesForPlayerSimulated correctly use the passed simulated board/pieces data. ---
        
        // --- Dummy placeholder for functions that were not explicitly asked to be changed again this round ---
        // --- but ensure they are compatible with piece IDs and gameData structure ---
        async function makeMoveOnFirestore(movedPieceId, newRow, newCol, isCastling = false, rookIdToMove = null, rookTargetCol = null) { /* ... from previous version ... */ 
            if (gameOver) return;
            console.log(`[makeMoveOnFirestore] Moving ${movedPieceId} to ${newRow},${newCol}. Castling: ${isCastling}`);

            const batch = writeBatch(db);
            const updates = {};

            const pieceToMoveData = { ...gameData.piecesData[movedPieceId] };
            const oldRow = pieceToMoveData.row;
            const oldCol = pieceToMoveData.col;

            updates[`piecesData.${movedPieceId}.row`] = newRow;
            updates[`piecesData.${movedPieceId}.col`] = newCol;
            updates[`piecesData.${movedPieceId}.hasMoved`] = true;

            const newBoardState = gameData.boardState.map(r => r.slice()); 
            newBoardState[oldRow][oldCol] = null;
            newBoardState[newRow][newCol] = movedPieceId;

            const capturedPieceId = gameData.boardState[newRow][newCol]; // This is the piece ID at the target *before* moving current piece
            if (capturedPieceId && capturedPieceId !== movedPieceId) { 
                updates[`piecesData.${capturedPieceId}`] = null; // Mark as captured by nullifying its data
                console.log(`Piece ${capturedPieceId} captured.`);
            }

            if (isCastling && rookIdToMove) {
                const rookToMoveData = { ...gameData.piecesData[rookIdToMove] };
                const rookOldRow = rookToMoveData.row;
                const rookOldCol = rookToMoveData.col;
                updates[`piecesData.${rookIdToMove}.col`] = rookTargetCol;
                updates[`piecesData.${rookIdToMove}.hasMoved`] = true;
                newBoardState[rookOldRow][rookOldCol] = null;
                newBoardState[rookOldRow][rookTargetCol] = rookIdToMove;
                console.log(`Castling: Rook ${rookIdToMove} moved to ${rookOldRow},${rookTargetCol}`);
            }
            
            updates.boardState = newBoardState;
            const nextPlayer = gameData.currentPlayer === 'white' ? 'black' : 'white';
            updates.currentPlayer = nextPlayer;
            updates.lastMoveTimestamp = serverTimestamp();
            
            // Create temporary states for check/checkmate evaluation
            let tempPiecesDataForCheck = JSON.parse(JSON.stringify(gameData.piecesData));
            tempPiecesDataForCheck[movedPieceId].row = newRow;
            tempPiecesDataForCheck[movedPieceId].col = newCol;
            tempPiecesDataForCheck[movedPieceId].hasMoved = true;
            if(capturedPieceId && capturedPieceId !== movedPieceId) delete tempPiecesDataForCheck[capturedPieceId]; // Actually remove if nullifying above
            else if (updates[`piecesData.${capturedPieceId}`] === null) delete tempPiecesDataForCheck[capturedPieceId];


            if(isCastling && rookIdToMove) {
                tempPiecesDataForCheck[rookIdToMove].col = rookTargetCol;
                tempPiecesDataForCheck[rookIdToMove].hasMoved = true;
            }

            const kingInCheckAfterMove = isKingInCheckSimulated(nextPlayer, newBoardState, tempPiecesDataForCheck);
            updates.check = kingInCheckAfterMove;
            updates.checkedPlayer = kingInCheckAfterMove ? nextPlayer : null;
            
            const legalMovesForNextPlayer = getAllLegalMovesForPlayerSimulated(nextPlayer, newBoardState, tempPiecesDataForCheck);

            if (kingInCheckAfterMove && legalMovesForNextPlayer.length === 0) {
                updates.gameOver = true;
                updates.winner = gameData.currentPlayer; 
                console.log(`Checkmate! Winner: ${updates.winner}`);
            } else if (!kingInCheckAfterMove && legalMovesForNextPlayer.length === 0) {
                updates.gameOver = true;
                updates.winner = 'draw'; 
                console.log("Stalemate! Draw.");
            } else {
                updates.gameOver = false; // Ensure game is not over if no mate/stalemate
                updates.winner = null;
            }

            batch.update(gameDocRef, updates);
            try {
                await batch.commit();
                console.log("[makeMoveOnFirestore] Move committed.");
                selectedPiece = null; 
                clearHighlights();    
            } catch (error) {
                console.error("[makeMoveOnFirestore] Error committing move:", error);
                showMessage("Error making move. Please try again.");
            }
        }

        function disposePiece(piece) { /* ... same as before ... */ 
            if (!piece) return;
            if (piece.children && piece.children.length > 0) {
                piece.children.forEach(child => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) { if (Array.isArray(child.material)) child.material.forEach(mat => mat.dispose()); else child.material.dispose(); }
                });
            } else {
                if (piece.geometry) piece.geometry.dispose();
                if (piece.material) { if (Array.isArray(piece.material)) piece.material.forEach(mat => mat.dispose()); else piece.material.dispose(); }
            }
        }
        function triggerConfetti() { /* ... same as before ... */ 
             if (!scene) return;
            for (let i = 0; i < 200; i++) {
                const geometry = new THREE.SphereGeometry(0.3, 8, 8); 
                const material = new THREE.MeshBasicMaterial({ color: confettiColors[Math.floor(Math.random() * confettiColors.length)] });
                const particle = new THREE.Mesh(geometry, material);
                particle.position.set( (Math.random() - 0.5) * 150, 100 + (Math.random() - 0.5) * 20, (Math.random() - 0.5) * 150 );
                particle.velocity = new THREE.Vector3( (Math.random() - 0.5) * 0.5, -Math.random() * 0.5 - 0.2, (Math.random() - 0.5) * 0.5 );
                particle.life = 200 + Math.random() * 100; 
                scene.add(particle); confettiParticles.push(particle);
            }
        }
        function animateConfetti() { /* ... same as before ... */ 
            for (let i = confettiParticles.length - 1; i >= 0; i--) {
                const particle = confettiParticles[i]; particle.position.add(particle.velocity); particle.life--;
                if (particle.life <= 0) { scene.remove(particle); disposePiece(particle); confettiParticles.splice(i, 1); }
            }
        }
        function animate() { /* ... same as before ... */ 
            requestAnimationFrame(animate); 
            if(controls) controls.update(); 
            if(renderer && scene && camera) renderer.render(scene, camera); 
            if (confettiParticles.length > 0) animateConfetti();
        }

    </script>
</body>
</html>
